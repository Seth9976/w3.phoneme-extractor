/* automatically generated by rust-bindgen 0.69.4 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const DEFAULT_RADIX: u32 = 12;
pub const SIZEOF_LONG: u32 = 4;
pub const SIZEOF_LONG_LONG: u32 = 8;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const PS_VAD_DEFAULT_SAMPLE_RATE: u32 = 16000;
pub const PS_VAD_DEFAULT_FRAME_LENGTH: f64 = 0.03;
pub const PS_ENDPOINTER_DEFAULT_WINDOW: f64 = 0.3;
pub const PS_ENDPOINTER_DEFAULT_RATIO: f64 = 0.9;
pub const NGRAM_INVALID_WID: i32 = -1;
pub const PS_ALIGNMENT_NONE: i32 = -1;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__iobuf() {
    const UNINIT: ::std::mem::MaybeUninit<_iobuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_iobuf>(),
        8usize,
        concat!("Size of: ", stringify!(_iobuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_iobuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_iobuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Placeholder) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_iobuf),
            "::",
            stringify!(_Placeholder)
        )
    );
}
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
#[doc = " @union anytype_t pocketsphinx/prim_type.h\n @brief Literally any type!\n\n (correction: not literally any type, but all the ones we use for configuration)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union anytype_s {
    pub ptr: *mut ::std::os::raw::c_void,
    pub i: ::std::os::raw::c_long,
    pub ui: ::std::os::raw::c_ulong,
    pub fl: f64,
}
#[test]
fn bindgen_test_layout_anytype_s() {
    const UNINIT: ::std::mem::MaybeUninit<anytype_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<anytype_s>(),
        8usize,
        concat!("Size of: ", stringify!(anytype_s))
    );
    assert_eq!(
        ::std::mem::align_of::<anytype_s>(),
        8usize,
        concat!("Alignment of ", stringify!(anytype_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anytype_s),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anytype_s),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ui) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anytype_s),
            "::",
            stringify!(ui)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anytype_s),
            "::",
            stringify!(fl)
        )
    );
}
#[doc = " @union anytype_t pocketsphinx/prim_type.h\n @brief Literally any type!\n\n (correction: not literally any type, but all the ones we use for configuration)"]
pub type anytype_t = anytype_s;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type int32 = i32;
pub type int16 = i16;
pub type int8 = i8;
pub type uint32 = u32;
pub type uint16 = u16;
pub type uint8 = u8;
pub type int64 = i64;
pub type uint64 = u64;
pub type float32 = f32;
pub type float64 = f64;
#[doc = " @struct logadd_t pocketsphinx/logmath.h\n @brief Integer log math computation table.\n\n This is exposed here to allow log-add computations to be inlined."]
pub type logadd_t = logadd_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct logadd_s {
    #[doc = " Table, in unsigned integers of (width) bytes."]
    pub table: *mut ::std::os::raw::c_void,
    #[doc = " Number of elements in (table).  This is never smaller than 256 (important!)"]
    pub table_size: uint32,
    #[doc = " Width of elements of (table)."]
    pub width: uint8,
    #[doc = " Right shift applied to elements in (table)."]
    pub shift: int8,
}
#[test]
fn bindgen_test_layout_logadd_s() {
    const UNINIT: ::std::mem::MaybeUninit<logadd_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<logadd_s>(),
        16usize,
        concat!("Size of: ", stringify!(logadd_s))
    );
    assert_eq!(
        ::std::mem::align_of::<logadd_s>(),
        8usize,
        concat!("Alignment of ", stringify!(logadd_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(logadd_s),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(logadd_s),
            "::",
            stringify!(table_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(logadd_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(logadd_s),
            "::",
            stringify!(shift)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct logmath_s {
    _unused: [u8; 0],
}
#[doc = " @struct logmath_t pocketsphinx/logmath.h\n @brief Integer log math computation class."]
pub type logmath_t = logmath_s;
extern "C" {
    #[doc = " Initialize a log math computation table.\n @memberof logmath_t\n @param base The base B in which computation is to be done.\n @param shift Log values are shifted right by this many bits.\n @param use_table Whether to use an add table or not\n @return The newly created log math table."]
    pub fn logmath_init(
        base: float64,
        shift: ::std::os::raw::c_int,
        use_table: ::std::os::raw::c_int,
    ) -> *mut logmath_t;
}
extern "C" {
    #[doc = " Memory-map (or read) a log table from a file.\n @memberof logmath_t"]
    pub fn logmath_read(filename: *const ::std::os::raw::c_char) -> *mut logmath_t;
}
extern "C" {
    #[doc = " Write a log table to a file.\n @memberof logmath_t"]
    pub fn logmath_write(lmath: *mut logmath_t, filename: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    #[doc = " Get the log table size and dimensions.\n @memberof logmath_t"]
    pub fn logmath_get_table_shape(
        lmath: *mut logmath_t,
        out_size: *mut uint32,
        out_width: *mut uint32,
        out_shift: *mut uint32,
    ) -> int32;
}
extern "C" {
    #[doc = " Get the log base.\n @memberof logmath_t"]
    pub fn logmath_get_base(lmath: *mut logmath_t) -> float64;
}
extern "C" {
    #[doc = " Get the smallest possible value represented in this base.\n @memberof logmath_t"]
    pub fn logmath_get_zero(lmath: *mut logmath_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the width of the values in a log table.\n @memberof logmath_t"]
    pub fn logmath_get_width(lmath: *mut logmath_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the shift of the values in a log table.\n @memberof logmath_t"]
    pub fn logmath_get_shift(lmath: *mut logmath_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retain ownership of a log table.\n\n @memberof logmath_t\n @return pointer to retained log table."]
    pub fn logmath_retain(lmath: *mut logmath_t) -> *mut logmath_t;
}
extern "C" {
    #[doc = " Free a log table.\n\n @memberof logmath_t\n @return new reference count (0 if freed completely)"]
    pub fn logmath_free(lmath: *mut logmath_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add two values in log space exactly and slowly (without using add table).\n @memberof logmath_t"]
    pub fn logmath_add_exact(
        lmath: *mut logmath_t,
        logb_p: ::std::os::raw::c_int,
        logb_q: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add two values in log space (i.e. return log(exp(p)+exp(q)))\n @memberof logmath_t"]
    pub fn logmath_add(
        lmath: *mut logmath_t,
        logb_p: ::std::os::raw::c_int,
        logb_q: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert linear floating point number to integer log in base B.\n @memberof logmath_t"]
    pub fn logmath_log(lmath: *mut logmath_t, p: float64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert integer log in base B to linear floating point.\n @memberof logmath_t"]
    pub fn logmath_exp(lmath: *mut logmath_t, logb_p: ::std::os::raw::c_int) -> float64;
}
extern "C" {
    #[doc = " Convert natural log (in floating point) to integer log in base B.\n @memberof logmath_t"]
    pub fn logmath_ln_to_log(lmath: *mut logmath_t, log_p: float64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert integer log in base B to natural log (in floating point).\n @memberof logmath_t"]
    pub fn logmath_log_to_ln(lmath: *mut logmath_t, logb_p: ::std::os::raw::c_int) -> float64;
}
extern "C" {
    #[doc = " Convert base 10 log (in floating point) to integer log in base B.\n @memberof logmath_t"]
    pub fn logmath_log10_to_log(lmath: *mut logmath_t, log_p: float64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert base 10 log (in floating point) to float log in base B.\n @memberof logmath_t"]
    pub fn logmath_log10_to_log_float(lmath: *mut logmath_t, log_p: float64) -> f32;
}
extern "C" {
    #[doc = " Convert integer log in base B to base 10 log (in floating point).\n @memberof logmath_t"]
    pub fn logmath_log_to_log10(lmath: *mut logmath_t, logb_p: ::std::os::raw::c_int) -> float64;
}
extern "C" {
    #[doc = " Convert float log in base B to base 10 log.\n @memberof logmath_t"]
    pub fn logmath_log_float_to_log10(lmath: *mut logmath_t, log_p: f32) -> float64;
}
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
pub const err_e_ERR_DEBUG: err_e = 0;
pub const err_e_ERR_INFO: err_e = 1;
pub const err_e_ERR_WARN: err_e = 2;
pub const err_e_ERR_ERROR: err_e = 3;
pub const err_e_ERR_FATAL: err_e = 4;
pub const err_e_ERR_MAX: err_e = 5;
pub type err_e = ::std::os::raw::c_int;
pub use self::err_e as err_lvl_t;
extern "C" {
    pub fn err_msg(
        lvl: err_lvl_t,
        path: *const ::std::os::raw::c_char,
        ln: ::std::os::raw::c_long,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn err_msg_system(
        lvl: err_lvl_t,
        path: *const ::std::os::raw::c_char,
        ln: ::std::os::raw::c_long,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn err_logfp_cb(
        user_data: *mut ::std::os::raw::c_void,
        level: err_lvl_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
pub type err_cb_f = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        arg1: err_lvl_t,
        arg2: *const ::std::os::raw::c_char,
        ...
    ),
>;
extern "C" {
    #[doc = " Set minimum logging level.\n\n @param lvl Level below which messages will not be logged (note\n ERR_DEBUG messages are not logged unless compiled in debugging\n mode)\n @return previous log level."]
    pub fn err_set_loglevel(lvl: err_lvl_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set minimum logging levelfrom a string\n\n @param lvl Level below which messages will not be logged (note\n ERR_DEBUG messages are not logged unless compiled in debugging\n mode).  A string corresponding to the names in enum err_e, but\n without the leading \"ERR_\" prefix.\n @return previous log level string, or NULL for invalid argument."]
    pub fn err_set_loglevel_str(
        lvl: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets function to output error messages. Use it to redirect the logging\n to your application. By default the handler which dumps messages to\n stderr is set.\n\n @param callback callback to pass messages too\n @param user_data data to pass to callback"]
    pub fn err_set_callback(callback: err_cb_f, user_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Direct all logging to a given filehandle if default logfp callback is set.\n\n @param stream Filehandle to send log messages to, or NULL to disable logging."]
    pub fn err_set_logfp(stream: *mut FILE);
}
extern "C" {
    #[doc = " Get the current logging filehandle.\n\n @return Current logging filehandle, NULL if logging is disabled. Initially\n it returns stderr"]
    pub fn err_get_logfp() -> *mut FILE;
}
extern "C" {
    #[doc = " Append all log messages to a given file.\n\n Previous logging filehandle is closed (unless it was stdout or stderr).\n\n @param path File path to send log messages to\n @return 0 for success, <0 for failure (e.g. if file does not exist)"]
    pub fn err_set_logfile(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_vad_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_vad_t pocketsphinx/vad.h\n @brief Voice activity detector."]
pub type ps_vad_t = ps_vad_s;
pub const ps_vad_mode_e_PS_VAD_LOOSE: ps_vad_mode_e = 0;
pub const ps_vad_mode_e_PS_VAD_MEDIUM_LOOSE: ps_vad_mode_e = 1;
pub const ps_vad_mode_e_PS_VAD_MEDIUM_STRICT: ps_vad_mode_e = 2;
pub const ps_vad_mode_e_PS_VAD_STRICT: ps_vad_mode_e = 3;
#[doc = " @enum ps_vad_mode_e pocketsphinx/vad.h\n @brief Voice activity detection \"aggressiveness\" levels."]
pub type ps_vad_mode_e = ::std::os::raw::c_int;
#[doc = " @enum ps_vad_mode_e pocketsphinx/vad.h\n @brief Voice activity detection \"aggressiveness\" levels."]
pub use self::ps_vad_mode_e as ps_vad_mode_t;
pub const ps_vad_class_e_PS_VAD_ERROR: ps_vad_class_e = -1;
pub const ps_vad_class_e_PS_VAD_NOT_SPEECH: ps_vad_class_e = 0;
pub const ps_vad_class_e_PS_VAD_SPEECH: ps_vad_class_e = 1;
#[doc = " @enum ps_vad_class_e pocketsphinx/vad.h\n @brief Classification of input frames returned by ps_vad_classify()."]
pub type ps_vad_class_e = ::std::os::raw::c_int;
#[doc = " @enum ps_vad_class_e pocketsphinx/vad.h\n @brief Classification of input frames returned by ps_vad_classify()."]
pub use self::ps_vad_class_e as ps_vad_class_t;
extern "C" {
    #[doc = " Initialize voice activity detection.\n\n @memberof ps_vad_t\n @param mode \"Aggressiveness\" of voice activity detection.  Stricter\n             values (see ps_vad_mode_t) are less likely to\n             misclassify non-speech as speech.\n @param sample_rate Sampling rate of input, or 0 for default (which can\n                    be obtained with ps_vad_sample_rate()).  Only 8000,\n                    16000, 32000, 48000 are directly supported.  See\n                    ps_vad_set_input_params() for more information.\n @param frame_length Frame length in seconds, or 0.0 for the default.  Only\n                     0.01, 0.02, 0.03 currently supported.  **Actual** value\n                     may differ, you must use ps_vad_frame_length() to\n                     obtain it.\n @return VAD object or NULL on failure (invalid parameter for instance)."]
    pub fn ps_vad_init(
        mode: ps_vad_mode_t,
        sample_rate: ::std::os::raw::c_int,
        frame_length: f64,
    ) -> *mut ps_vad_t;
}
extern "C" {
    #[doc = " Retain a pointer to voice activity detector.\n\n @memberof ps_vad_t\n @param vad Voice activity detector.\n @return Voice activity detector with incremented reference count."]
    pub fn ps_vad_retain(vad: *mut ps_vad_t) -> *mut ps_vad_t;
}
extern "C" {
    #[doc = " Release a pointer to voice activity detector.\n\n @memberof ps_vad_t\n @param vad Voice activity detector.\n @return New reference count (0 if freed)."]
    pub fn ps_vad_free(vad: *mut ps_vad_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the input parameters for voice activity detection.\n\n @memberof ps_vad_t\n @param sample_rate Sampling rate of input, or 0 for default (which can\n                    be obtained with ps_vad_sample_rate()).  Only 8000,\n                    16000, 32000, 48000 are directly supported, others\n                    will use the closest supported rate (within reason).\n                    Note that this means that the actual frame length\n                    may not be exactly the one requested, so you must\n                    always use the one returned by ps_vad_frame_size()\n                    (in samples) or ps_vad_frame_length() (in seconds).\n @param frame_length Requested frame length in seconds, or 0.0 for the\n                     default.  Only 0.01, 0.02, 0.03 currently supported.\n                     **Actual frame length may be different, you must\n                     always use ps_vad_frame_length() to obtain it.**\n @return 0 for success or -1 on error."]
    pub fn ps_vad_set_input_params(
        vad: *mut ps_vad_t,
        sample_rate: ::std::os::raw::c_int,
        frame_length: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the sampling rate expected by voice activity detection.\n\n @memberof ps_vad_t\n @param vad Voice activity detector.\n @return Expected sampling rate."]
    pub fn ps_vad_sample_rate(vad: *mut ps_vad_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of samples expected by voice activity detection.\n\n You **must** always ensure that the buffers passed to\n ps_vad_classify() contain this number of samples (zero-pad them if\n necessary).\n\n @memberof ps_vad_t\n @param vad Voice activity detector.\n @return Size, in samples, of the frames passed to ps_vad_classify()."]
    pub fn ps_vad_frame_size(vad: *mut ps_vad_t) -> usize;
}
extern "C" {
    #[doc = " Classify a frame as speech or not speech.\n\n @memberof ps_vad_t\n @param vad Voice activity detector.\n @param frame Frame of input, **must** contain the number of\n              samples returned by ps_vad_frame_size().\n @return PS_VAD_SPEECH, PS_VAD_NOT_SPEECH, or PS_VAD_ERROR (see\n         ps_vad_class_t)."]
    pub fn ps_vad_classify(vad: *mut ps_vad_t, frame: *const int16) -> ps_vad_class_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_endpointer_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_endpointer_t pocketsphinx/endpointer.h\n @brief Simple voice activity detection based endpointing"]
pub type ps_endpointer_t = ps_endpointer_s;
extern "C" {
    #[doc = " Initialize endpointing.\n\n @memberof ps_endpointer_t\n @param window Seconds of audio to use in speech start/end decision,\n               or 0 to use the default (PS_ENDPOINTER_DEFAULT_WINDOW).\n @param ratio Ratio of frames needed to trigger start/end decision,\n              or 0 for the default (PS_ENDPOINTER_DEFAULT_RATIO).\n @param mode \"Aggressiveness\" of voice activity detection.  Stricter\n             values (see ps_vad_mode_t) are less likely to\n             misclassify non-speech as speech.\n @param sample_rate Sampling rate of input, or 0 for default (which can\n                    be obtained with ps_vad_sample_rate()).  Only 8000,\n                    16000, 32000, 48000 are directly supported, others\n                    will use the closest supported rate (within reason).\n                    Note that this means that the actual frame length\n                    may not be exactly the one requested, so you must\n                    always use the one returned by\n                    ps_endpointer_frame_size()\n                    (in samples) or ps_endpointer_frame_length() (in\n                    seconds).\n @param frame_length Requested frame length in seconds, or 0.0 for the\n                     default.  Only 0.01, 0.02, 0.03 currently supported.\n                     **Actual frame length may be different, you must\n                     always use ps_endpointer_frame_length() to obtain it.**\n @return Endpointer object or NULL on failure (invalid parameter for\n instance)."]
    pub fn ps_endpointer_init(
        window: f64,
        ratio: f64,
        mode: ps_vad_mode_t,
        sample_rate: ::std::os::raw::c_int,
        frame_length: f64,
    ) -> *mut ps_endpointer_t;
}
extern "C" {
    #[doc = " Retain a pointer to endpointer\n\n @memberof ps_endpointer_t\n @param ep Endpointer.\n @return Endpointer with incremented reference count."]
    pub fn ps_endpointer_retain(ep: *mut ps_endpointer_t) -> *mut ps_endpointer_t;
}
extern "C" {
    #[doc = " Release a pointer to endpointer.\n\n @memberof ps_endpointer_t\n @param ep Endpointer\n @return New reference count (0 if freed)."]
    pub fn ps_endpointer_free(ep: *mut ps_endpointer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the voice activity detector used by the endpointer.\n\n @memberof ps_endpointer_t\n @return VAD object. The endpointer retains ownership of this\n object, so you must use ps_vad_retain() if you wish to use it\n outside of the lifetime of the endpointer."]
    pub fn ps_endpointer_vad(ep: *mut ps_endpointer_t) -> *mut ps_vad_t;
}
extern "C" {
    #[doc = " Process a frame of audio, returning a frame if in a speech region.\n\n Note that the endpointer is *not* thread-safe.  You must call all\n endpointer functions from the same thread.\n\n @memberof ps_endpointer_t\n @param ep Endpointer.\n @param frame Frame of data, must contain ps_endpointer_frame_size()\n              samples.\n @return NULL if no speech available, or pointer to a frame of\n         ps_endpointer_frame_size() samples (no more and no less)."]
    pub fn ps_endpointer_process(ep: *mut ps_endpointer_t, frame: *const int16) -> *const int16;
}
extern "C" {
    #[doc = " Process remaining samples at end of stream.\n\n Note that the endpointer is *not* thread-safe.  You must call all\n endpointer functions from the same thread.\n\n @memberof ps_endpointer_t\n @param ep Endpointer.\n @param frame Frame of data, must contain ps_endpointer_frame_size()\n              samples or less.\n @param nsamp: Number of samples in frame.\n @param out_nsamp: Output, number of samples available.\n @return Pointer to available samples, or NULL if none available."]
    pub fn ps_endpointer_end_stream(
        ep: *mut ps_endpointer_t,
        frame: *const int16,
        nsamp: usize,
        out_nsamp: *mut usize,
    ) -> *const int16;
}
extern "C" {
    #[doc = " Get the current state (speech/not-speech) of the endpointer.\n\n This function can be used to detect speech/non-speech transitions.\n If it returns 0, and a subsequent call to ps_endpointer_process()\n returns non-NULL, this indicates a transition to speech.\n Conversely, if ps_endpointer_process() returns non-NULL and a\n subsequent call to this function returns 0, this indicates a\n transition to non-speech.\n\n @memberof ps_endpointer_t\n @param ep Endpointer.\n @return non-zero if in a speech segment after processing the last\n         frame of data."]
    pub fn ps_endpointer_in_speech(ep: *mut ps_endpointer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the start time of the last speech segment.\n @memberof ps_endpointer_t"]
    pub fn ps_endpointer_speech_start(ep: *mut ps_endpointer_t) -> f64;
}
extern "C" {
    #[doc = " Get the end time of the last speech segment\n @memberof ps_endpointer_t"]
    pub fn ps_endpointer_speech_end(ep: *mut ps_endpointer_t) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_ln_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_config_t\n @brief configuration object."]
pub type ps_config_t = cmd_ln_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jsgf_s {
    _unused: [u8; 0],
}
#[doc = " @struct jsgf_t pocketsphinx/model.h\n @brief JSGF parser"]
pub type jsgf_t = jsgf_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct jsgf_rule_s {
    _unused: [u8; 0],
}
#[doc = " @struct jsgf_rule_t pocketsphinx/model.h\n @brief Rule in a parsed JSGF grammar."]
pub type jsgf_rule_t = jsgf_rule_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsg_model_s {
    _unused: [u8; 0],
}
#[doc = " @struct fsg_model_t pocketsphinx/model.h\n @brief Finite-state grammar.\n\n States are simply integers 0..n_state-1.\n A transition emits a word and has a given probability of being taken.\n There can also be null or epsilon transitions, with no associated emitted\n word."]
pub type fsg_model_t = fsg_model_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngram_model_s {
    _unused: [u8; 0],
}
#[doc = " @struct ngram_model_t pocketsphinx/model.h\n @brief N-Gram based language model."]
pub type ngram_model_t = ngram_model_s;
extern "C" {
    #[doc = " Parse a JSGF grammar from a file.\n\n @memberof jsgf_t\n @param filename the name of the file to parse.\n @param parent optional parent grammar for this one (NULL, usually).\n @return new JSGF grammar object, or NULL on failure."]
    pub fn jsgf_parse_file(
        filename: *const ::std::os::raw::c_char,
        parent: *mut jsgf_t,
    ) -> *mut jsgf_t;
}
extern "C" {
    #[doc = " Parse a JSGF grammar from a string.\n\n @memberof jsgf_t\n @param string 0-terminated string with grammar.\n @param parent optional parent grammar for this one (NULL, usually).\n @return new JSGF grammar object, or NULL on failure."]
    pub fn jsgf_parse_string(
        string: *const ::std::os::raw::c_char,
        parent: *mut jsgf_t,
    ) -> *mut jsgf_t;
}
extern "C" {
    #[doc = " Get the grammar name from the file.\n @memberof jsgf_t"]
    pub fn jsgf_grammar_name(jsgf: *mut jsgf_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Free a JSGF grammar.\n @memberof jsgf_t"]
    pub fn jsgf_grammar_free(jsgf: *mut jsgf_t);
}
extern "C" {
    #[doc = " Get a rule by name from a grammar. Name should not contain brackets.\n @memberof jsgf_t"]
    pub fn jsgf_get_rule(
        grammar: *mut jsgf_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut jsgf_rule_t;
}
extern "C" {
    #[doc = " Returns the first public rule of the grammar\n @memberof jsgf_t"]
    pub fn jsgf_get_public_rule(grammar: *mut jsgf_t) -> *mut jsgf_rule_t;
}
extern "C" {
    #[doc = " Get the rule name from a rule.\n @memberof jsgf_rule_t"]
    pub fn jsgf_rule_name(rule: *mut jsgf_rule_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Test if a rule is public or not.\n @memberof jsgf_rule_t"]
    pub fn jsgf_rule_public(rule: *mut jsgf_rule_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hash_iter_s {
    _unused: [u8; 0],
}
#[doc = " @struct jsgf_rule_iter_t\n @brief Iterator over rules in a grammar."]
pub type jsgf_rule_iter_t = hash_iter_s;
extern "C" {
    #[doc = " Get an iterator over all rules in a grammar.\n @memberof jsgf_t"]
    pub fn jsgf_rule_iter(grammar: *mut jsgf_t) -> *mut jsgf_rule_iter_t;
}
extern "C" {
    #[doc = " Advance an iterator to the next rule in the grammar.\n @memberof jsgf_rule_iter_t"]
    pub fn jsgf_rule_iter_next(itor: *mut jsgf_rule_iter_t) -> *mut jsgf_rule_iter_t;
}
extern "C" {
    #[doc = " Get the current rule in a rule iterator.\n @memberof jsgf_rule_iter_t"]
    pub fn jsgf_rule_iter_rule(itor: *mut jsgf_rule_iter_t) -> *mut jsgf_rule_t;
}
extern "C" {
    #[doc = " Free a rule iterator (if the end hasn't been reached).\n @memberof jsgf_rule_iter_t"]
    pub fn jsgf_rule_iter_free(itor: *mut jsgf_rule_iter_t);
}
extern "C" {
    #[doc = " Build a Sphinx FSG object from a JSGF rule.\n @memberof jsgf_t"]
    pub fn jsgf_build_fsg(
        grammar: *mut jsgf_t,
        rule: *mut jsgf_rule_t,
        lmath: *mut logmath_t,
        lw: float32,
    ) -> *mut fsg_model_t;
}
extern "C" {
    #[doc = " Read JSGF from file and return FSG object from it.\n\n This function looks for a first public rule in jsgf and constructs JSGF from it.\n @memberof fsg_model_t"]
    pub fn jsgf_read_file(
        file: *const ::std::os::raw::c_char,
        lmath: *mut logmath_t,
        lw: float32,
    ) -> *mut fsg_model_t;
}
extern "C" {
    #[doc = " Read JSGF from string and return FSG object from it.\n\n This function looks for a first public rule in jsgf and constructs JSGF from it.\n @memberof fsg_model_t"]
    pub fn jsgf_read_string(
        string: *const ::std::os::raw::c_char,
        lmath: *mut logmath_t,
        lw: float32,
    ) -> *mut fsg_model_t;
}
extern "C" {
    #[doc = " Convert a JSGF rule to Sphinx FSG text form.\n\n This does a direct conversion without doing transitive closure on\n null transitions and so forth.\n @memberof jsgf_t"]
    pub fn jsgf_write_fsg(
        grammar: *mut jsgf_t,
        rule: *mut jsgf_rule_t,
        outfh: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retain ownership of an FSG.\n\n @return Pointer to retained FSG.\n @memberof fsg_model_t"]
    pub fn fsg_model_retain(fsg: *mut fsg_model_t) -> *mut fsg_model_t;
}
extern "C" {
    #[doc = " Free the given word FSG.\n\n @memberof fsg_model_t\n @return new reference count (0 if freed completely)"]
    pub fn fsg_model_free(fsg: *mut fsg_model_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a word FSG from the given file and return a pointer to the structure\n created.  Return NULL if any error occurred.\n\n File format:\n\n <pre>\n   Any number of comment lines; ignored\n   FSG_BEGIN [<fsgname>]\n   N <#states>\n   S <start-state ID>\n   F <final-state ID>\n   T <from-state> <to-state> <prob> [<word-string>]\n   T ...\n   ... (any number of state transitions)\n   FSG_END\n   Any number of comment lines; ignored\n </pre>\n\n The FSG spec begins with the line containing the keyword FSG_BEGIN.\n It has an optional fsg name string.  If not present, the FSG has the empty\n string as its name.\n\n Following the FSG_BEGIN declaration is the number of states, the start\n state, and the final state, each on a separate line.  States are numbered\n in the range [0 .. <numberofstate>-1].\n\n These are followed by all the state transitions, each on a separate line,\n and terminated by the FSG_END line.  A state transition has the given\n probability of being taken, and emits the given word.  The word emission\n is optional; if word-string omitted, it is an epsilon or null transition.\n\n Comments can also be embedded within the FSG body proper (i.e. between\n FSG_BEGIN and FSG_END): any line with a # character in col 1 is treated\n as a comment line.\n\n Return value: a new fsg_model_t structure if the file is successfully\n read, NULL otherwise.\n @memberof fsg_model_t"]
    pub fn fsg_model_readfile(
        file: *const ::std::os::raw::c_char,
        lmath: *mut logmath_t,
        lw: float32,
    ) -> *mut fsg_model_t;
}
extern "C" {
    #[doc = " Like fsg_model_readfile(), but from an already open stream.\n @memberof fsg_model_t"]
    pub fn fsg_model_read(fp: *mut FILE, lmath: *mut logmath_t, lw: float32) -> *mut fsg_model_t;
}
extern "C" {
    #[doc = " Check that an FSG accepts a word sequence\n\n @memberof fsg_model_t\n @param words Whitespace-separated word sequence\n @return 1 if accepts, 0 if not."]
    pub fn fsg_model_accept(
        fsg: *mut fsg_model_t,
        words: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write FSG to a file.\n @memberof fsg_model_t"]
    pub fn fsg_model_write(fsg: *mut fsg_model_t, fp: *mut FILE);
}
extern "C" {
    #[doc = " Write FSG to a file.\n @memberof fsg_model_t"]
    pub fn fsg_model_writefile(fsg: *mut fsg_model_t, file: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Write FSG to a file in AT&T FSM format.\n @memberof fsg_model_t"]
    pub fn fsg_model_write_fsm(fsg: *mut fsg_model_t, fp: *mut FILE);
}
extern "C" {
    #[doc = " Write FSG to a file in AT&T FSM format.\n @memberof fsg_model_t"]
    pub fn fsg_model_writefile_fsm(fsg: *mut fsg_model_t, file: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Write FSG symbol table to a file (for AT&T FSM)\n @memberof fsg_model_t"]
    pub fn fsg_model_write_symtab(fsg: *mut fsg_model_t, file: *mut FILE);
}
extern "C" {
    #[doc = " Write FSG symbol table to a file (for AT&T FSM)\n @memberof fsg_model_t"]
    pub fn fsg_model_writefile_symtab(fsg: *mut fsg_model_t, file: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngram_class_s {
    _unused: [u8; 0],
}
#[doc = " @struct ngram_class_t pocketsphinx/model.h\n @brief Word class in an N-Gram model."]
pub type ngram_class_t = ngram_class_s;
#[doc = "< Not a valid file type."]
pub const ngram_file_type_e_NGRAM_INVALID: ngram_file_type_e = -1;
#[doc = "< Determine file type automatically."]
pub const ngram_file_type_e_NGRAM_AUTO: ngram_file_type_e = 0;
#[doc = "< ARPABO text format (the standard)."]
pub const ngram_file_type_e_NGRAM_ARPA: ngram_file_type_e = 1;
#[doc = "< Sphinx .DMP format."]
pub const ngram_file_type_e_NGRAM_BIN: ngram_file_type_e = 2;
#[doc = " @enum ngram_file_type_e pocketsphinx/model.h\n @brief File types for N-Gram files"]
pub type ngram_file_type_e = ::std::os::raw::c_int;
#[doc = " @enum ngram_file_type_e pocketsphinx/model.h\n @brief File types for N-Gram files"]
pub use self::ngram_file_type_e as ngram_file_type_t;
extern "C" {
    #[doc = " Read an N-Gram model from a file on disk.\n\n @param config Optional pointer to a set of command-line arguments.\n Recognized arguments are:\n\n  - -mmap (boolean) whether to use memory-mapped I/O\n  - -lw (float32) language weight to apply to the model\n  - -wip (float32) word insertion penalty to apply to the model\n\n @memberof ngram_model_t\n @param file_name path to the file to read.\n @param file_type type of the file, or NGRAM_AUTO to determine automatically.\n @param lmath Log-math parameters to use for probability\n              calculations.  Ownership of this object is assumed by\n              the newly created ngram_model_t, and you should not\n              attempt to free it manually.  If you wish to reuse it\n              elsewhere, you must retain it with logmath_retain().\n @return newly created ngram_model_t."]
    pub fn ngram_model_read(
        config: *mut ps_config_t,
        file_name: *const ::std::os::raw::c_char,
        file_type: ngram_file_type_t,
        lmath: *mut logmath_t,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Write an N-Gram model to disk.\n\n @memberof ngram_model_t\n @return 0 for success, <0 on error"]
    pub fn ngram_model_write(
        model: *mut ngram_model_t,
        file_name: *const ::std::os::raw::c_char,
        format: ngram_file_type_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Guess the file type for an N-Gram model from the filename.\n\n @memberof ngram_model_t\n @return the guessed file type, or NGRAM_INVALID if none could be guessed."]
    pub fn ngram_file_name_to_type(file_name: *const ::std::os::raw::c_char) -> ngram_file_type_t;
}
extern "C" {
    #[doc = " Get the N-Gram file type from a string.\n\n @memberof ngram_model_t\n @return file type, or NGRAM_INVALID if no such file type exists."]
    pub fn ngram_str_to_type(str_name: *const ::std::os::raw::c_char) -> ngram_file_type_t;
}
extern "C" {
    #[doc = " Get the canonical name for an N-Gram file type.\n\n @memberof ngram_model_t\n @return read-only string with the name for this file type, or NULL\n if no such type exists."]
    pub fn ngram_type_to_str(type_: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retain ownership of an N-Gram model.\n\n @memberof ngram_model_t\n @return Pointer to retained model."]
    pub fn ngram_model_retain(model: *mut ngram_model_t) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Release memory associated with an N-Gram model.\n\n @memberof ngram_model_t\n @return new reference count (0 if freed completely)"]
    pub fn ngram_model_free(model: *mut ngram_model_t) -> ::std::os::raw::c_int;
}
#[doc = "< Upper case"]
pub const ngram_case_e_NGRAM_UPPER: ngram_case_e = 0;
#[doc = "< Lower case"]
pub const ngram_case_e_NGRAM_LOWER: ngram_case_e = 1;
#[doc = " @enum ngram_case_e pocketsphinx/model.h\n @brief Constants for case folding."]
pub type ngram_case_e = ::std::os::raw::c_int;
#[doc = " @enum ngram_case_e pocketsphinx/model.h\n @brief Constants for case folding."]
pub use self::ngram_case_e as ngram_case_t;
extern "C" {
    #[doc = " Case-fold word strings in an N-Gram model.\n\n WARNING: This is not Unicode aware, so any non-ASCII characters\n will not be converted.\n\n @memberof ngram_model_t"]
    pub fn ngram_model_casefold(
        model: *mut ngram_model_t,
        kase: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Apply a language weight, insertion penalty, and unigram weight to a\n language model.\n\n This will change the values output by ngram_score() and friends.\n This is done for efficiency since in decoding, these are the only\n values we actually need.  Call ngram_prob() if you want the \"raw\"\n N-Gram probability estimate.\n\n To remove all weighting, call ngram_apply_weights(model, 1.0, 1.0).\n\n @memberof ngram_model_t"]
    pub fn ngram_model_apply_weights(
        model: *mut ngram_model_t,
        lw: float32,
        wip: float32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current weights from a language model.\n\n @memberof ngram_model_t\n @param model The model in question.\n @param out_log_wip Output: (optional) logarithm of word insertion penalty.\n @return language weight."]
    pub fn ngram_model_get_weights(model: *mut ngram_model_t, out_log_wip: *mut int32) -> float32;
}
extern "C" {
    #[doc = " Get the score (scaled, interpolated log-probability) for a general\n N-Gram.\n\n The argument list consists of the history words (as null-terminated\n strings) of the N-Gram, <b>in reverse order</b>, followed by NULL.\n Therefore, if you wanted to get the N-Gram score for \"a whole joy\",\n you would call:\n\n <pre>\n  score = ngram_score(model, \"joy\", \"whole\", \"a\", NULL);\n </pre>\n\n This is not the function to use in decoding, because it has some\n overhead for looking up words.  Use ngram_ng_score(),\n ngram_tg_score(), or ngram_bg_score() instead.  In the future there\n will probably be a version that takes a general language model\n state object, to support suffix-array LM and things like that.\n\n If one of the words is not in the LM's vocabulary, the result will\n depend on whether this is an open or closed vocabulary language\n model.  For an open-vocabulary model, unknown words are all mapped\n to the unigram &lt;UNK&gt; which has a non-zero probability and also\n participates in higher-order N-Grams.  Therefore, you will get a\n score of some sort in this case.\n\n For a closed-vocabulary model, unknown words are impossible and\n thus have zero probability.  Therefore, if <code>word</code> is\n unknown, this function will return a \"zero\" log-probability, i.e. a\n large negative number.  To obtain this number for comparison, call\n ngram_zero().\n\n @memberof ngram_model_t"]
    pub fn ngram_score(
        model: *mut ngram_model_t,
        word: *const ::std::os::raw::c_char,
        ...
    ) -> int32;
}
extern "C" {
    #[doc = " Quick trigram score lookup.\n\n @memberof ngram_model_t"]
    pub fn ngram_tg_score(
        model: *mut ngram_model_t,
        w3: int32,
        w2: int32,
        w1: int32,
        n_used: *mut int32,
    ) -> int32;
}
extern "C" {
    #[doc = " Quick bigram score lookup.\n\n @memberof ngram_model_t"]
    pub fn ngram_bg_score(
        model: *mut ngram_model_t,
        w2: int32,
        w1: int32,
        n_used: *mut int32,
    ) -> int32;
}
extern "C" {
    #[doc = " Quick general N-Gram score lookup.\n\n @memberof ngram_model_t"]
    pub fn ngram_ng_score(
        model: *mut ngram_model_t,
        wid: int32,
        history: *mut int32,
        n_hist: int32,
        n_used: *mut int32,
    ) -> int32;
}
extern "C" {
    #[doc = " Get the \"raw\" log-probability for a general N-Gram.\n\n This returns the log-probability of an N-Gram, as defined in the\n language model file, before any language weighting, interpolation,\n or insertion penalty has been applied.\n\n @memberof ngram_model_t\n @note When backing off to a unigram from a bigram or trigram, the\n unigram weight (interpolation with uniform) is not removed."]
    pub fn ngram_probv(
        model: *mut ngram_model_t,
        word: *const ::std::os::raw::c_char,
        ...
    ) -> int32;
}
extern "C" {
    #[doc = " Get the \"raw\" log-probability for a general N-Gram.\n\n This returns the log-probability of an N-Gram, as defined in the\n language model file, before any language weighting, interpolation,\n or insertion penalty has been applied.\n\n @note When backing off to a unigram from a bigram or trigram, the\n unigram weight (interpolation with uniform) is not removed.\n @memberof ngram_model_t"]
    pub fn ngram_prob(
        model: *mut ngram_model_t,
        words: *const *const ::std::os::raw::c_char,
        n: int32,
    ) -> int32;
}
extern "C" {
    #[doc = " Quick \"raw\" probability lookup for a general N-Gram.\n\n See documentation for ngram_ng_score() and ngram_apply_weights()\n for an explanation of this.\n\n @memberof ngram_model_t"]
    pub fn ngram_ng_prob(
        model: *mut ngram_model_t,
        wid: int32,
        history: *mut int32,
        n_hist: int32,
        n_used: *mut int32,
    ) -> int32;
}
extern "C" {
    #[doc = " Convert score to \"raw\" log-probability.\n\n @note The unigram weight (interpolation with uniform) is not\n removed, since there is no way to know which order of N-Gram\n generated <code>score</code>.\n\n @memberof ngram_model_t\n @param model The N-Gram model from which score was obtained.\n @param score The N-Gram score to convert\n @return The raw log-probability value."]
    pub fn ngram_score_to_prob(model: *mut ngram_model_t, score: int32) -> int32;
}
extern "C" {
    #[doc = " Look up numerical word ID.\n\n @memberof ngram_model_t"]
    pub fn ngram_wid(model: *mut ngram_model_t, word: *const ::std::os::raw::c_char) -> int32;
}
extern "C" {
    #[doc = " Look up word string for numerical word ID.\n\n @memberof ngram_model_t"]
    pub fn ngram_word(model: *mut ngram_model_t, wid: int32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the unknown word ID for a language model.\n\n Language models can be either \"open vocabulary\" or \"closed\n vocabulary\".  The difference is that the former assigns a fixed\n non-zero unigram probability to unknown words, while the latter\n does not allow unknown words (or, equivalently, it assigns them\n zero probability).  If this is a closed vocabulary model, this\n function will return NGRAM_INVALID_WID.\n\n @memberof ngram_model_t\n @return The ID for the unknown word, or NGRAM_INVALID_WID if none\n exists."]
    pub fn ngram_unknown_wid(model: *mut ngram_model_t) -> int32;
}
extern "C" {
    #[doc = " Get the \"zero\" log-probability value for a language model.\n\n @memberof ngram_model_t"]
    pub fn ngram_zero(model: *mut ngram_model_t) -> int32;
}
extern "C" {
    #[doc = " Get the order of the N-gram model (i.e. the \"N\" in \"N-gram\")\n\n @memberof ngram_model_t"]
    pub fn ngram_model_get_size(model: *mut ngram_model_t) -> int32;
}
extern "C" {
    #[doc = " Get the counts of the various N-grams in the model.\n\n @memberof ngram_model_t"]
    pub fn ngram_model_get_counts(model: *mut ngram_model_t) -> *const uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngram_iter_s {
    _unused: [u8; 0],
}
#[doc = " @struct ngram_iter_t pocketsphinx/model.h\n @brief M-gram (yes, **M**-gram) iterator object.\n\n This is an iterator over the N-Gram successors of a given word or\n N-1-Gram, that is why it is called \"M\" and not \"N\"."]
pub type ngram_iter_t = ngram_iter_s;
extern "C" {
    #[doc = " Iterate over all M-grams.\n\n @memberof ngram_model_t\n @param model Language model to query.\n @param m Order of the M-Grams requested minus one (i.e. order of the history)\n @return An iterator over the requested M, or NULL if no N-grams of\n order M+1 exist."]
    pub fn ngram_model_mgrams(
        model: *mut ngram_model_t,
        m: ::std::os::raw::c_int,
    ) -> *mut ngram_iter_t;
}
extern "C" {
    #[doc = " Get an iterator over M-grams pointing to the specified M-gram.\n\n @memberof ngram_model_t"]
    pub fn ngram_iter(
        model: *mut ngram_model_t,
        word: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ngram_iter_t;
}
extern "C" {
    #[doc = " Get an iterator over M-grams pointing to the specified M-gram.\n\n @memberof ngram_model_t"]
    pub fn ngram_ng_iter(
        model: *mut ngram_model_t,
        wid: int32,
        history: *mut int32,
        n_hist: int32,
    ) -> *mut ngram_iter_t;
}
extern "C" {
    #[doc = " Get information from the current M-gram in an iterator.\n\n @memberof ngram_iter_t\n @param out_score Output: Score for this M-gram (including any word\n                          penalty and language weight).\n @param out_bowt Output: Backoff weight for this M-gram.\n @return read-only array of word IDs."]
    pub fn ngram_iter_get(
        itor: *mut ngram_iter_t,
        out_score: *mut int32,
        out_bowt: *mut int32,
    ) -> *const int32;
}
extern "C" {
    #[doc = " Iterate over all M-gram successors of an M-1-gram.\n\n @memberof ngram_iter_t\n @param itor Iterator pointing to the M-1-gram to get successors of."]
    pub fn ngram_iter_successors(itor: *mut ngram_iter_t) -> *mut ngram_iter_t;
}
extern "C" {
    #[doc = " Advance an M-gram iterator.\n @memberof ngram_iter_t"]
    pub fn ngram_iter_next(itor: *mut ngram_iter_t) -> *mut ngram_iter_t;
}
extern "C" {
    #[doc = " Terminate an M-gram iterator.\n @memberof ngram_iter_t"]
    pub fn ngram_iter_free(itor: *mut ngram_iter_t);
}
extern "C" {
    #[doc = " Add a word (unigram) to the language model.\n\n @note The semantics of this are not particularly well-defined for\n model sets, and may be subject to change.  Currently this will add\n the word to all of the submodels\n\n @memberof ngram_model_t\n @param model The model to add a word to.\n @param word Text of the word to add.\n @param weight Weight of this word relative to the uniform distribution.\n @return The word ID for the new word."]
    pub fn ngram_model_add_word(
        model: *mut ngram_model_t,
        word: *const ::std::os::raw::c_char,
        weight: float32,
    ) -> int32;
}
extern "C" {
    #[doc = " Read a class definition file and add classes to a language model.\n\n This function assumes that the class tags have already been defined\n as unigrams in the language model.  All words in the class\n definition will be added to the vocabulary as special in-class words.\n For this reason is is necessary that they not have the same names\n as any words in the general unigram distribution.  The convention\n is to suffix them with \":class_tag\", where class_tag is the class\n tag minus the enclosing square brackets.\n\n @memberof ngram_model_t\n @return 0 for success, <0 for error"]
    pub fn ngram_model_read_classdef(
        model: *mut ngram_model_t,
        file_name: *const ::std::os::raw::c_char,
    ) -> int32;
}
extern "C" {
    #[doc = " Add a new class to a language model.\n\n If <code>classname</code> already exists in the unigram set for\n <code>model</code>, then it will be converted to a class tag, and\n <code>classweight</code> will be ignored.  Otherwise, a new unigram\n will be created as in ngram_model_add_word().\n @memberof ngram_model_t"]
    pub fn ngram_model_add_class(
        model: *mut ngram_model_t,
        classname: *const ::std::os::raw::c_char,
        classweight: float32,
        words: *mut *mut ::std::os::raw::c_char,
        weights: *const float32,
        n_words: int32,
    ) -> int32;
}
extern "C" {
    #[doc = " Add a word to a class in a language model.\n\n @memberof ngram_model_t\n @param model The model to add a word to.\n @param classname Name of the class to add this word to.\n @param word Text of the word to add.\n @param weight Weight of this word relative to the within-class uniform distribution.\n @return The word ID for the new word."]
    pub fn ngram_model_add_class_word(
        model: *mut ngram_model_t,
        classname: *const ::std::os::raw::c_char,
        word: *const ::std::os::raw::c_char,
        weight: float32,
    ) -> int32;
}
extern "C" {
    #[doc = " Create a set of language models sharing a common space of word IDs.\n\n This function creates a meta-language model which groups together a\n set of language models, synchronizing word IDs between them.  To\n use this language model, you can either select a submodel to use\n exclusively using ngram_model_set_select(), or interpolate\n between scores from all models.  To do the latter, you can either\n pass a non-NULL value of the <code>weights</code> parameter, or\n re-activate interpolation later on by calling\n ngram_model_set_interp().\n\n In order to make this efficient, there are some restrictions on the\n models that can be grouped together.  The most important (and\n currently the only) one is that they <strong>must</strong> all\n share the same log-math parameters.\n\n @memberof ngram_model_t\n @param config Any configuration parameters to be shared between models.\n @param models Array of pointers to previously created language models.\n @param names Array of strings to use as unique identifiers for LMs.\n @param weights Array of weights to use in interpolating LMs, or NULL\n                for no interpolation.\n @param n_models Number of elements in the arrays passed to this function."]
    pub fn ngram_model_set_init(
        config: *mut ps_config_t,
        models: *mut *mut ngram_model_t,
        names: *mut *mut ::std::os::raw::c_char,
        weights: *const float32,
        n_models: int32,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Read a set of language models from a control file.\n\n This file creates a language model set from a \"control file\" of\n the type used in Sphinx-II and Sphinx-III.\n File format (optional stuff is indicated by enclosing in []):\n\n <pre>\n   [{ LMClassFileName LMClassFilename ... }]\n   TrigramLMFileName LMName [{ LMClassName LMClassName ... }]\n   TrigramLMFileName LMName [{ LMClassName LMClassName ... }]\n   ...\n (There should be whitespace around the { and } delimiters.)\n </pre>\n\n This is an extension of the older format that had only TrigramLMFilenName\n and LMName pairs.  The new format allows a set of LMClass files to be read\n in and referred to by the trigram LMs.\n\n No \"comments\" allowed in this file.\n\n @memberof ngram_model_t\n @param config Configuration parameters.\n @param lmctlfile Path to the language model control file.\n @param lmath Log-math parameters to use for probability\n              calculations.  Ownership of this object is assumed by\n              the newly created ngram_model_t, and you should not\n              attempt to free it manually.  If you wish to reuse it\n              elsewhere, you must retain it with logmath_retain().\n @return newly created language model set."]
    pub fn ngram_model_set_read(
        config: *mut ps_config_t,
        lmctlfile: *const ::std::os::raw::c_char,
        lmath: *mut logmath_t,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Returns the number of language models in a set.\n @memberof ngram_model_t"]
    pub fn ngram_model_set_count(set: *mut ngram_model_t) -> int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ngram_model_set_iter_s {
    _unused: [u8; 0],
}
#[doc = " @struct ngram_model_set_iter_t pocketsphinx/model.h\n @brief Iterator over language models in a set."]
pub type ngram_model_set_iter_t = ngram_model_set_iter_s;
extern "C" {
    #[doc = " Begin iterating over language models in a set.\n\n @memberof ngram_model_t\n @return iterator pointing to the first language model, or NULL if no models remain."]
    pub fn ngram_model_set_iter(set: *mut ngram_model_t) -> *mut ngram_model_set_iter_t;
}
extern "C" {
    #[doc = " Move to the next language model in a set.\n\n @memberof ngram_model_set_iter_t\n @return iterator pointing to the next language model, or NULL if no models remain."]
    pub fn ngram_model_set_iter_next(
        itor: *mut ngram_model_set_iter_t,
    ) -> *mut ngram_model_set_iter_t;
}
extern "C" {
    #[doc = " Finish iteration over a langauge model set.\n @memberof ngram_model_set_iter_t"]
    pub fn ngram_model_set_iter_free(itor: *mut ngram_model_set_iter_t);
}
extern "C" {
    #[doc = " Get language model and associated name from an iterator.\n\n @memberof ngram_model_set_iter_t\n @param itor the iterator\n @param lmname Output: string name associated with this language model.\n @return Language model pointed to by this iterator."]
    pub fn ngram_model_set_iter_model(
        itor: *mut ngram_model_set_iter_t,
        lmname: *mut *const ::std::os::raw::c_char,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Select a single language model from a set for scoring.\n\n @memberof ngram_model_t\n @return the newly selected language model, or NULL if no language\n model by that name exists."]
    pub fn ngram_model_set_select(
        set: *mut ngram_model_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Look up a language model by name from a set.\n\n @memberof ngram_model_t\n @return language model corresponding to <code>name</code>, or NULL\n if no language model by that name exists."]
    pub fn ngram_model_set_lookup(
        set: *mut ngram_model_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Get the current language model name, if any.\n @memberof ngram_model_t"]
    pub fn ngram_model_set_current(set: *mut ngram_model_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set interpolation weights for a set and enables interpolation.\n\n If <code>weights</code> is NULL, any previously initialized set of\n weights will be used.  If no weights were specified to\n ngram_model_set_init(), then a uniform distribution will be used.\n\n @memberof ngram_model_t"]
    pub fn ngram_model_set_interp(
        set: *mut ngram_model_t,
        names: *mut *const ::std::os::raw::c_char,
        weights: *const float32,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Add a language model to a set.\n\n @memberof ngram_model_t\n @param set The language model set to add to.\n @param model The language model to add.\n @param name The name to associate with this model.\n @param weight Interpolation weight for this model, relative to the\n               uniform distribution.  1.0 is a safe value.\n @param reuse_widmap Reuse the existing word-ID mapping in\n <code>set</code>.  Any new words present in <code>model</code>\n will not be added to the word-ID mapping in this case."]
    pub fn ngram_model_set_add(
        set: *mut ngram_model_t,
        model: *mut ngram_model_t,
        name: *const ::std::os::raw::c_char,
        weight: float32,
        reuse_widmap: ::std::os::raw::c_int,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Remove a language model from a set.\n\n @memberof ngram_model_t\n @param set The language model set to remove from.\n @param name The name associated with the model to remove.\n @param reuse_widmap Reuse the existing word-ID mapping in\n                     <code>set</code>."]
    pub fn ngram_model_set_remove(
        set: *mut ngram_model_t,
        name: *const ::std::os::raw::c_char,
        reuse_widmap: ::std::os::raw::c_int,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Set the word-to-ID mapping for this model set.\n @memberof ngram_model_t"]
    pub fn ngram_model_set_map_words(
        set: *mut ngram_model_t,
        words: *mut *const ::std::os::raw::c_char,
        n_words: int32,
    );
}
extern "C" {
    #[doc = " Query the word-ID mapping for the current language model.\n\n @memberof ngram_model_t\n @return the local word ID in the current language model, or\n NGRAM_INVALID_WID if <code>set_wid</code> is invalid or\n interpolation is enabled."]
    pub fn ngram_model_set_current_wid(set: *mut ngram_model_t, set_wid: int32) -> int32;
}
extern "C" {
    #[doc = " Test whether a word ID corresponds to a known word in the current\n state of the language model set.\n\n @memberof ngram_model_t\n @return If there is a current language model, returns non-zero if\n <code>set_wid</code> corresponds to a known word in that language\n model.  Otherwise, returns non-zero if <code>set_wid</code>\n corresponds to a known word in any language model."]
    pub fn ngram_model_set_known_wid(set: *mut ngram_model_t, set_wid: int32) -> int32;
}
extern "C" {
    #[doc = " Flush any cached N-Gram information\n @memberof ngram_model_t"]
    pub fn ngram_model_flush(lm: *mut ngram_model_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_alignment_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_alignment_t pocketsphinx/alignment.h\n @brief Multi-level alignment (words, phones, states) over an utterance."]
pub type ps_alignment_t = ps_alignment_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_alignment_iter_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_alignment_iter_t pocketsphinx/alignment.h\n @brief Iterator over entries in an alignment."]
pub type ps_alignment_iter_t = ps_alignment_iter_s;
extern "C" {
    #[doc = " Retain an alighment\n @memberof ps_alignment_t"]
    pub fn ps_alignment_retain(al: *mut ps_alignment_t) -> *mut ps_alignment_t;
}
extern "C" {
    #[doc = " Release an alignment\n @memberof ps_alignment_t"]
    pub fn ps_alignment_free(al: *mut ps_alignment_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate over the alignment starting at the first word.\n @memberof ps_alignment_t"]
    pub fn ps_alignment_words(al: *mut ps_alignment_t) -> *mut ps_alignment_iter_t;
}
extern "C" {
    #[doc = " Iterate over the alignment starting at the first phone.\n @memberof ps_alignment_t"]
    pub fn ps_alignment_phones(al: *mut ps_alignment_t) -> *mut ps_alignment_iter_t;
}
extern "C" {
    #[doc = " Iterate over the alignment starting at the first state.\n @memberof ps_alignment_t"]
    pub fn ps_alignment_states(al: *mut ps_alignment_t) -> *mut ps_alignment_iter_t;
}
extern "C" {
    #[doc = " Get the human-readable name of the current segment for an alignment.\n\n @memberof ps_alignment_iter_t\n @return Name of this segment as a string (word, phone, or state\n number).  This pointer is owned by the iterator, do not free it\n yourself."]
    pub fn ps_alignment_iter_name(itor: *mut ps_alignment_iter_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the timing and score information for the current segment of an aligment.\n\n @memberof ps_alignment_iter_t\n @arg start Output pointer for start frame\n @arg duration Output pointer for duration\n @return Acoustic score for this segment"]
    pub fn ps_alignment_iter_seg(
        itor: *mut ps_alignment_iter_t,
        start: *mut ::std::os::raw::c_int,
        duration: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move an alignment iterator forward.\n\n If the end of the alignment is reached, this will free the iterator\n and return NULL.\n\n @memberof ps_alignment_iter_t"]
    pub fn ps_alignment_iter_next(itor: *mut ps_alignment_iter_t) -> *mut ps_alignment_iter_t;
}
extern "C" {
    #[doc = " Iterate over the children of the current alignment entry.\n\n If there are no child nodes, NULL is returned.\n\n @memberof ps_alignment_iter_t"]
    pub fn ps_alignment_iter_children(itor: *mut ps_alignment_iter_t) -> *mut ps_alignment_iter_t;
}
extern "C" {
    #[doc = " Release an iterator before completing all iterations.\n\n @memberof ps_alignment_iter_t"]
    pub fn ps_alignment_iter_free(itor: *mut ps_alignment_iter_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_search_iter_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_search_iter_t pocketsphinx/search.h\n @brief Iterator over search modules."]
pub type ps_search_iter_t = ps_search_iter_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_decoder_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_decoder_t\n @brief Speech recognizer object."]
pub type ps_decoder_t = ps_decoder_s;
extern "C" {
    #[doc = " Actives search with the provided name.\n\n @memberof ps_decoder_t\n @param name Name of search module to activate. This must have been\n previously added by either ps_add_fsg(), ps_add_lm(), or\n ps_add_kws().  If NULL, it will re-activate the default search,\n which is useful when running second-pass alignment, for instance.\n @return 0 on success, -1 on failure"]
    pub fn ps_activate_search(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns name of current search in decoder\n\n @memberof ps_decoder_t\n @see ps_activate_search"]
    pub fn ps_current_search(ps: *mut ps_decoder_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Removes a search module and releases its resources.\n\n Removes a search module previously added with\n using ps_add_fsg(), ps_add_lm(), ps_add_kws(), etc.\n\n @memberof ps_decoder_t\n @see ps_add_fsg\n @see ps_add_lm\n @see ps_add_kws"]
    pub fn ps_remove_search(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns iterator over current searches\n\n @memberof ps_decoder_t\n @see ps_activate_search"]
    pub fn ps_search_iter(ps: *mut ps_decoder_t) -> *mut ps_search_iter_t;
}
extern "C" {
    #[doc = " Updates search iterator to point to the next position.\n\n @memberof ps_search_iter_t\n This function automatically frees the iterator object upon reaching\n the final entry.\n @see ps_activate_search"]
    pub fn ps_search_iter_next(itor: *mut ps_search_iter_t) -> *mut ps_search_iter_t;
}
extern "C" {
    #[doc = " Retrieves the name of the search the iterator points to.\n\n @memberof ps_search_iter_t\n @see ps_activate_search"]
    pub fn ps_search_iter_val(itor: *mut ps_search_iter_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Delete an unfinished search iterator\n\n @memberof ps_search_iter_t\n @see ps_activate_search"]
    pub fn ps_search_iter_free(itor: *mut ps_search_iter_t);
}
extern "C" {
    #[doc = " Get the language model or lmset object associated with a search.\n\n @memberof ps_decoder_t\n @arg name Name of language model search, or NULL for current search.\n @return The language model (possibly set of language models) object\n         for this decoder.  The decoder retains ownership of this\n         pointer, so you should not attempt to free it manually.\n         Use ngram_model_retain() if you wish to reuse it elsewhere."]
    pub fn ps_get_lm(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ngram_model_t;
}
extern "C" {
    #[doc = " Adds new search based on N-gram language model.\n\n Associates N-gram search with the provided name. The search can be activated\n using ps_activate_search().\n\n @memberof ps_decoder_t\n @see ps_activate_search."]
    pub fn ps_add_lm(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        lm: *mut ngram_model_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds new search based on N-gram language model.\n\n Convenient method to load N-gram model and create a search.\n\n @memberof ps_decoder_t\n @see ps_add_lm"]
    pub fn ps_add_lm_file(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the finite-state grammar set object associated with a search.\n\n @memberof ps_decoder_t\n @arg name Name of FSG search, or NULL for current search.\n @return The current FSG set object for this decoder, or\n         NULL if `name` does not correspond to an FSG search."]
    pub fn ps_get_fsg(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
    ) -> *mut fsg_model_t;
}
extern "C" {
    #[doc = " Adds new search based on finite state grammar.\n\n Associates FSG search with the provided name. The search can be\n activated using ps_activate_search().\n\n @memberof ps_decoder_t\n @see ps_activate_search"]
    pub fn ps_add_fsg(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        fsg: *mut fsg_model_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds new search using JSGF model.\n\n Convenient method to load JSGF model and create a search.\n\n @memberof ps_decoder_t\n @see ps_add_fsg"]
    pub fn ps_add_jsgf_file(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds new search using JSGF model.\n\n Convenience method to parse JSGF model from string and create a search.\n\n @memberof ps_decoder_t\n @see ps_add_fsg"]
    pub fn ps_add_jsgf_string(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        jsgf_string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the keyphrase associated with a KWS search\n\n @memberof ps_decoder_t\n @arg name Name of KWS search, or NULL for current search.\n @return The current keyphrase to spot, or NULL if `name` does not\n correspond to a KWS search"]
    pub fn ps_get_kws(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Adds keyphrases from a file to spotting\n\n Associates KWS search with the provided name. The search can be activated\n using ps_activate_search().\n\n @memberof ps_decoder_t\n @see ps_activate_search"]
    pub fn ps_add_kws(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        keyfile: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds new keyphrase to spot\n\n Associates KWS search with the provided name. The search can be activated\n using ps_activate_search().\n\n @memberof ps_decoder_t\n @see ps_activate_search"]
    pub fn ps_add_keyphrase(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        keyphrase: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds new search based on phone N-gram language model.\n\n Associates N-gram search with the provided name. The search can be activated\n using ps_activate_search().\n\n @memberof ps_decoder_t\n @see ps_activate_search."]
    pub fn ps_add_allphone(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        lm: *mut ngram_model_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adds new search based on phone N-gram language model.\n\n Convenient method to load N-gram model and create a search.\n\n @memberof ps_decoder_t\n @see ps_add_allphone"]
    pub fn ps_add_allphone_file(
        ps: *mut ps_decoder_t,
        name: *const ::std::os::raw::c_char,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set up decoder to force-align a word sequence.\n\n Unlike the `ps_add_*` functions, this activates the search module\n immediately, since force-alignment is nearly always a single shot.\n Currently \"under the hood\" this is an FSG search but you shouldn't\n depend on that.  The search module activated is *not* the default\n search, so you can return to that one by calling ps_activate_search\n with `NULL`.\n\n Decoding proceeds as normal, though only this word sequence will be\n recognized, with silences and alternate pronunciations inserted.\n Word alignments are available with ps_seg_iter().  To obtain\n phoneme or state segmentations, you must subsequently call\n ps_set_alignment() and re-run decoding.  It's tough son, but it's life.\n\n @memberof ps_decoder_t\n @param ps Decoder\n @param words String containing whitespace-separated words for alignment.\n              These words are assumed to exist in the current dictionary.\n"]
    pub fn ps_set_align_text(
        ps: *mut ps_decoder_t,
        words: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set up decoder to run phone and state-level alignment.\n\n Unlike the `ps_add_*` functions, this activates the search module\n immediately, since force-alignment is nearly always a single shot.\n\n To align, run or re-run decoding as usual, then call\n ps_get_alignment() to get the resulting alignment.  Note that if\n you call this function *before* rerunning decoding, you can obtain\n the phone and state sequence, but the durations will be invalid\n (phones and states will inherit the parent word's duration).\n\n @memberof ps_decoder_t\n @param ps Decoder object.\n @param al Usually NULL, which means to construct an alignment from\n           the current search hypothesis (this does not work with\n           allphone or keyword spotting).  You can also pass a\n           ps_alignment_t here if you have one.  The search will\n           retain but not copy it, so after running decoding it will\n           be updated with new durations.  You can set starts and\n           durations for words or phones (not states) to constrain\n           the alignment.\n @return 0 for success, -1 for error (if there is no search\n         hypothesis, or it cannot be aligned due to missing word\n         IDs)"]
    pub fn ps_set_alignment(
        ps: *mut ps_decoder_t,
        al: *mut ps_alignment_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the alignment associated with the current search module.\n\n As noted above, if decoding has not been run, this will contain\n invalid durations, but that may still be useful if you just want to\n know the state sequence.\n\n @memberof ps_decoder_t\n @return Current alignment, or NULL if none.  This pointer is owned\n         by the decoder, so you must call ps_alignment_retain() on\n         it if you wish to keep it outside the lifetime of the\n         decoder."]
    pub fn ps_get_alignment(ps: *mut ps_decoder_t) -> *mut ps_alignment_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_lattice_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_lattice_t pocketsphinx/lattice.h\n @brief Word graph structure used in bestpath/nbest search."]
pub type ps_lattice_t = ps_lattice_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_latnode_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_latnode_t pocketsphinx/lattice.h\n @brief Node in a word lattice\n\n A node corresponds to a number of hypothesized instances of a word\n which all share the same starting point."]
pub type ps_latnode_t = ps_latnode_s;
#[doc = " @struct ps_latnode_iter_t pocketsphinx/lattice.h\n @brief Iterator over DAG nodes."]
pub type ps_latnode_iter_t = ps_latnode_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_latlink_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_latlink_t pocketsphinx/lattice.h\n @brief Link between DAG nodes.\n\n A link corresponds to a single hypothesized instance of a word with\n a given start and end point."]
pub type ps_latlink_t = ps_latlink_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct latlink_list_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_latlink_iter_t pocketsphinx/lattice.h\n @brief Iterator over DAG links."]
pub type ps_latlink_iter_t = latlink_list_s;
extern "C" {
    #[doc = " Read a lattice from a file on disk.\n\n @memberof ps_lattice_t\n @param ps Decoder to use for processing this lattice, or NULL.\n @param file Path to lattice file.\n @return Newly created lattice, or NULL for failure."]
    pub fn ps_lattice_read(
        ps: *mut ps_decoder_s,
        file: *const ::std::os::raw::c_char,
    ) -> *mut ps_lattice_t;
}
extern "C" {
    #[doc = " Retain a lattice.\n\n This function retains ownership of a lattice for the caller,\n preventing it from being freed automatically.  You must call\n ps_lattice_free() to free it after having called this function.\n\n @memberof ps_lattice_t\n @return pointer to the retained lattice."]
    pub fn ps_lattice_retain(dag: *mut ps_lattice_t) -> *mut ps_lattice_t;
}
extern "C" {
    #[doc = " Free a lattice.\n\n @memberof ps_lattice_t\n @return new reference count (0 if dag was freed)"]
    pub fn ps_lattice_free(dag: *mut ps_lattice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a lattice to disk.\n\n @memberof ps_lattice_t\n @return 0 for success, <0 on failure."]
    pub fn ps_lattice_write(
        dag: *mut ps_lattice_t,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a lattice to disk in HTK format\n\n @memberof ps_lattice_t\n @return 0 for success, <0 on failure."]
    pub fn ps_lattice_write_htk(
        dag: *mut ps_lattice_t,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the log-math computation object for this lattice\n\n @memberof ps_lattice_t\n @return The log-math object for this lattice.  The lattice retains\n         ownership of this pointer, so you should not attempt to\n         free it manually.  Use logmath_retain() if you wish to\n         reuse it elsewhere."]
    pub fn ps_lattice_get_logmath(dag: *mut ps_lattice_t) -> *mut logmath_t;
}
extern "C" {
    #[doc = " Start iterating over nodes in the lattice.\n\n @note No particular order of traversal is guaranteed, and you\n should not depend on this.\n\n @memberof ps_lattice_t\n @param dag Lattice to iterate over.\n @return Iterator over lattice nodes."]
    pub fn ps_latnode_iter(dag: *mut ps_lattice_t) -> *mut ps_latnode_iter_t;
}
extern "C" {
    #[doc = " Move to next node in iteration.\n @memberof ps_latnode_iter_t\n @param itor Node iterator.\n @return Updated node iterator, or NULL if finished"]
    pub fn ps_latnode_iter_next(itor: *mut ps_latnode_iter_t) -> *mut ps_latnode_iter_t;
}
extern "C" {
    #[doc = " Stop iterating over nodes.\n @memberof ps_latnode_iter_t\n @param itor Node iterator."]
    pub fn ps_latnode_iter_free(itor: *mut ps_latnode_iter_t);
}
extern "C" {
    #[doc = " Get node from iterator.\n @memberof ps_latnode_iter_t"]
    pub fn ps_latnode_iter_node(itor: *mut ps_latnode_iter_t) -> *mut ps_latnode_t;
}
extern "C" {
    #[doc = " Get start and end time range for a node.\n\n @memberof ps_latnode_iter_t\n @param node Node inquired about.\n @param out_fef Output: End frame of first exit from this node.\n @param out_lef Output: End frame of last exit from this node.\n @return Start frame for all edges exiting this node."]
    pub fn ps_latnode_times(
        node: *mut ps_latnode_t,
        out_fef: *mut int16,
        out_lef: *mut int16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get word string for this node.\n\n @memberof ps_latnode_t\n @param dag Lattice to which node belongs.\n @param node Node inquired about.\n @return Word string for this node (possibly a pronunciation variant)."]
    pub fn ps_latnode_word(
        dag: *mut ps_lattice_t,
        node: *mut ps_latnode_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get base word string for this node.\n\n @memberof ps_latnode_t\n @param dag Lattice to which node belongs.\n @param node Node inquired about.\n @return Base word string for this node."]
    pub fn ps_latnode_baseword(
        dag: *mut ps_lattice_t,
        node: *mut ps_latnode_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Iterate over exits from this node.\n\n @memberof ps_latnode_t\n @param node Node inquired about.\n @return Iterator over exit links from this node."]
    pub fn ps_latnode_exits(node: *mut ps_latnode_t) -> *mut ps_latlink_iter_t;
}
extern "C" {
    #[doc = " Iterate over entries to this node.\n\n @memberof ps_latnode_t\n @param node Node inquired about.\n @return Iterator over entry links to this node."]
    pub fn ps_latnode_entries(node: *mut ps_latnode_t) -> *mut ps_latlink_iter_t;
}
extern "C" {
    #[doc = " Get best posterior probability and associated acoustic score from a lattice node.\n\n @memberof ps_latnode_t\n @param dag Lattice to which node belongs.\n @param node Node inquired about.\n @param out_link Output: exit link with highest posterior probability\n @return Posterior probability of the best link exiting this node.\n         Log is expressed in the log-base used in the decoder.  To\n         convert to linear floating-point, use\n         logmath_exp(ps_lattice_get_logmath(), pprob)."]
    pub fn ps_latnode_prob(
        dag: *mut ps_lattice_t,
        node: *mut ps_latnode_t,
        out_link: *mut *mut ps_latlink_t,
    ) -> int32;
}
extern "C" {
    #[doc = " Get next link from a lattice link iterator.\n\n @memberof ps_latlink_iter_t\n @param itor Iterator.\n @return Updated iterator, or NULL if finished."]
    pub fn ps_latlink_iter_next(itor: *mut ps_latlink_iter_t) -> *mut ps_latlink_iter_t;
}
extern "C" {
    #[doc = " Stop iterating over links.\n @memberof ps_latlink_iter_t\n @param itor Link iterator."]
    pub fn ps_latlink_iter_free(itor: *mut ps_latlink_iter_t);
}
extern "C" {
    #[doc = " Get link from iterator.\n @memberof ps_latlink_iter_t"]
    pub fn ps_latlink_iter_link(itor: *mut ps_latlink_iter_t) -> *mut ps_latlink_t;
}
extern "C" {
    #[doc = " Get start and end times from a lattice link.\n\n @note these are <strong>inclusive</strong> - i.e. the last frame of\n this word is ef, not ef-1.\n\n @memberof ps_latlink_t\n @param link Link inquired about.\n @param out_sf Output: (optional) start frame of this link.\n @return End frame of this link."]
    pub fn ps_latlink_times(link: *mut ps_latlink_t, out_sf: *mut int16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get destination and source nodes from a lattice link\n\n @memberof ps_latlink_t\n @param link Link inquired about\n @param out_src Output: (optional) source node.\n @return destination node"]
    pub fn ps_latlink_nodes(
        link: *mut ps_latlink_t,
        out_src: *mut *mut ps_latnode_t,
    ) -> *mut ps_latnode_t;
}
extern "C" {
    #[doc = " Get word string from a lattice link.\n\n @memberof ps_latlink_t\n @param dag Lattice to which node belongs.\n @param link Link inquired about\n @return Word string for this link (possibly a pronunciation variant)."]
    pub fn ps_latlink_word(
        dag: *mut ps_lattice_t,
        link: *mut ps_latlink_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get base word string from a lattice link.\n\n @memberof ps_latlink_t\n @param dag Lattice to which node belongs.\n @param link Link inquired about\n @return Base word string for this link"]
    pub fn ps_latlink_baseword(
        dag: *mut ps_lattice_t,
        link: *mut ps_latlink_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get predecessor link in best path.\n\n @memberof ps_latlink_t\n @param link Link inquired about\n @return Best previous link from bestpath search, if any.  Otherwise NULL"]
    pub fn ps_latlink_pred(link: *mut ps_latlink_t) -> *mut ps_latlink_t;
}
extern "C" {
    #[doc = " Get acoustic score and posterior probability from a lattice link.\n\n @memberof ps_latlink_t\n @param dag Lattice to which node belongs.\n @param link Link inquired about\n @param out_ascr Output: (optional) acoustic score.\n @return Posterior probability for this link.  Log is expressed in\n         the log-base used in the decoder.  To convert to linear\n         floating-point, use logmath_exp(ps_lattice_get_logmath(), pprob)."]
    pub fn ps_latlink_prob(
        dag: *mut ps_lattice_t,
        link: *mut ps_latlink_t,
        out_ascr: *mut int32,
    ) -> int32;
}
extern "C" {
    #[doc = " Create a directed link between \"from\" and \"to\" nodes, but if a link already exists,\n choose one with the best link_scr.\n\n @memberof ps_lattice_t"]
    pub fn ps_lattice_link(
        dag: *mut ps_lattice_t,
        from: *mut ps_latnode_t,
        to: *mut ps_latnode_t,
        score: int32,
        ef: int32,
    );
}
extern "C" {
    #[doc = " Start a forward traversal of edges in a word graph.\n\n @note A keen eye will notice an inconsistency in this API versus\n other types of iterators in PocketSphinx.  The reason for this is\n that the traversal algorithm is much more efficient when it is able\n to modify the lattice structure.  Therefore, to avoid giving the\n impression that multiple traversals are possible at once, no\n separate iterator structure is provided.\n\n @memberof ps_lattice_t\n @param dag Lattice to be traversed.\n @param start Start node (source) of traversal.\n @param end End node (goal) of traversal.\n @return First link in traversal."]
    pub fn ps_lattice_traverse_edges(
        dag: *mut ps_lattice_t,
        start: *mut ps_latnode_t,
        end: *mut ps_latnode_t,
    ) -> *mut ps_latlink_t;
}
extern "C" {
    #[doc = " Get the next link in forward traversal.\n\n @memberof ps_lattice_t\n @param dag Lattice to be traversed.\n @param end End node (goal) of traversal.\n @return Next link in traversal."]
    pub fn ps_lattice_traverse_next(
        dag: *mut ps_lattice_t,
        end: *mut ps_latnode_t,
    ) -> *mut ps_latlink_t;
}
extern "C" {
    #[doc = " Start a reverse traversal of edges in a word graph.\n\n @note See ps_lattice_traverse_edges() for why this API is the way it is.\n\n @memberof ps_lattice_t\n @param dag Lattice to be traversed.\n @param start Start node (goal) of traversal.\n @param end End node (source) of traversal.\n @return First link in traversal."]
    pub fn ps_lattice_reverse_edges(
        dag: *mut ps_lattice_t,
        start: *mut ps_latnode_t,
        end: *mut ps_latnode_t,
    ) -> *mut ps_latlink_t;
}
extern "C" {
    #[doc = " Get the next link in reverse traversal.\n\n @memberof ps_lattice_t\n @param dag Lattice to be traversed.\n @param start Start node (goal) of traversal.\n @return Next link in traversal."]
    pub fn ps_lattice_reverse_next(
        dag: *mut ps_lattice_t,
        start: *mut ps_latnode_t,
    ) -> *mut ps_latlink_t;
}
extern "C" {
    #[doc = " Do N-Gram based best-path search on a word graph.\n\n This function calculates both the best path as well as the forward\n probability used in confidence estimation.\n\n @memberof ps_lattice_t\n @return Final link in best path, NULL on error."]
    pub fn ps_lattice_bestpath(
        dag: *mut ps_lattice_t,
        lmset: *mut ngram_model_t,
        lwf: float32,
        ascale: float32,
    ) -> *mut ps_latlink_t;
}
extern "C" {
    #[doc = " Calculate link posterior probabilities on a word graph.\n\n This function assumes that bestpath search has already been done.\n\n @memberof ps_lattice_t\n @return Posterior probability of the utterance as a whole."]
    pub fn ps_lattice_posterior(
        dag: *mut ps_lattice_t,
        lmset: *mut ngram_model_t,
        ascale: float32,
    ) -> int32;
}
extern "C" {
    #[doc = " Prune all links (and associated nodes) below a certain posterior probability.\n\n This function assumes that ps_lattice_posterior() has already been called.\n\n @memberof ps_lattice_t\n @param beam Minimum posterior probability for links. This is\n         expressed in the log-base used in the decoder.  To convert\n         from linear floating-point, use\n         logmath_log(ps_lattice_get_logmath(), prob).\n @return number of arcs removed."]
    pub fn ps_lattice_posterior_prune(dag: *mut ps_lattice_t, beam: int32) -> int32;
}
extern "C" {
    #[doc = " Get the number of frames in the lattice.\n\n @memberof ps_lattice_t\n @param dag The lattice in question.\n @return Number of frames in this lattice."]
    pub fn ps_lattice_n_frames(dag: *mut ps_lattice_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_mllr_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_mllr_t pocketsphinx/mllr.h\n @brief Linear transform object."]
pub type ps_mllr_t = ps_mllr_s;
extern "C" {
    #[doc = " Read a speaker-adaptive linear transform from a file.\n @memberof ps_mllr_t"]
    pub fn ps_mllr_read(file: *const ::std::os::raw::c_char) -> *mut ps_mllr_t;
}
extern "C" {
    #[doc = " Retain a pointer to a linear transform.\n @memberof ps_mllr_t"]
    pub fn ps_mllr_retain(mllr: *mut ps_mllr_t) -> *mut ps_mllr_t;
}
extern "C" {
    #[doc = " Release a pointer to a linear transform.\n @memberof ps_mllr_t"]
    pub fn ps_mllr_free(mllr: *mut ps_mllr_t) -> ::std::os::raw::c_int;
}
pub const ps_type_e_ARG_REQUIRED: ps_type_e = 1;
pub const ps_type_e_ARG_INTEGER: ps_type_e = 2;
pub const ps_type_e_ARG_FLOATING: ps_type_e = 4;
pub const ps_type_e_ARG_STRING: ps_type_e = 8;
pub const ps_type_e_ARG_BOOLEAN: ps_type_e = 16;
pub const ps_type_e_REQARG_INTEGER: ps_type_e = 3;
pub const ps_type_e_REQARG_FLOATING: ps_type_e = 5;
pub const ps_type_e_REQARG_STRING: ps_type_e = 9;
pub const ps_type_e_REQARG_BOOLEAN: ps_type_e = 17;
#[doc = " @enum ps_type_e\n @brief Types of configuration parameters."]
pub type ps_type_e = ::std::os::raw::c_int;
#[doc = " @enum ps_type_e\n @brief Types of configuration parameters."]
pub use self::ps_type_e as ps_type_t;
#[doc = " @struct ps_arg_t\n @brief Definition of a configuration parameter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_arg_s {
    #[doc = "< Name of the command line switch"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Type of the argument in question"]
    pub type_: ::std::os::raw::c_int,
    #[doc = "< Default value (as a character string), or NULL if none"]
    pub deflt: *const ::std::os::raw::c_char,
    #[doc = "< Documentation/description string"]
    pub doc: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ps_arg_s() {
    const UNINIT: ::std::mem::MaybeUninit<ps_arg_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ps_arg_s>(),
        32usize,
        concat!("Size of: ", stringify!(ps_arg_s))
    );
    assert_eq!(
        ::std::mem::align_of::<ps_arg_s>(),
        8usize,
        concat!("Alignment of ", stringify!(ps_arg_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ps_arg_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ps_arg_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deflt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ps_arg_s),
            "::",
            stringify!(deflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ps_arg_s),
            "::",
            stringify!(doc)
        )
    );
}
#[doc = " @struct ps_arg_t\n @brief Definition of a configuration parameter."]
pub type ps_arg_t = ps_arg_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_astar_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_nbest_t\n @brief N-best hypothesis iterator object."]
pub type ps_nbest_t = ps_astar_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ps_seg_s {
    _unused: [u8; 0],
}
#[doc = " @struct ps_seg_t\n @brief Segmentation iterator object."]
pub type ps_seg_t = ps_seg_s;
extern "C" {
    #[doc = " Create a configuration with default values.\n\n @memberof ps_config_t\n @param defn Array of ps_arg_t defining and describing parameters,\n terminated by an ps_arg_t with `name == NULL`.  You should usually\n just pass NULL here, which will result in the standard set of\n parameters being used.\n @return Newly created configuration or NULL on failure (should not\n happen, but check it anyway)."]
    pub fn ps_config_init(defn: *const ps_arg_t) -> *mut ps_config_t;
}
extern "C" {
    #[doc = " Retain a pointer to a configuration object.\n @memberof ps_config_t"]
    pub fn ps_config_retain(config: *mut ps_config_t) -> *mut ps_config_t;
}
extern "C" {
    #[doc = " Release a configuration object.\n @memberof ps_config_t"]
    pub fn ps_config_free(config: *mut ps_config_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Validate configuration.\n\n Currently this just checks that you haven't specified multiple\n types of grammars or language models at the same time.\n\n @memberof ps_config_t\n @return 0 for success, <0 for failure."]
    pub fn ps_config_validate(config: *mut ps_config_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create or update a configuration by parsing slightly extended JSON.\n\n This function parses a JSON object in non-strict mode to produce a\n ps_config_t.  Configuration parameters are given *without* a\n leading dash, and do not need to be quoted, nor does the object\n need to be enclosed in curly braces, nor are commas necessary\n between key/value pairs.  Basically, it's degenerate YAML.  So, for\n example, this is accepted:\n\n     hmm: fr-fr\n     samprate: 8000\n     keyphrase: \"hello world\"\n\n Of course, valid JSON is also accepted, but who wants to use that.\n\n Well, mostly.  Unicode escape sequences (e.g. `\"\\u0020\"`) are *not*\n supported at the moment, so please don't use them.\n\n @memberof ps_config_t\n @arg config Previously existing ps_config_t to update, or NULL to\n create a new one.\n @arg json JSON serialized object as null-terminated UTF-8,\n containing configuration parameters.\n @return Newly created configuration or NULL on failure (such as\n invalid or missing parameters)."]
    pub fn ps_config_parse_json(
        config: *mut ps_config_t,
        json: *const ::std::os::raw::c_char,
    ) -> *mut ps_config_t;
}
extern "C" {
    #[doc = " Construct JSON from a configuration object.\n\n Unlike ps_config_parse_json(), this actually produces valid JSON ;-)\n\n @memberof ps_config_t\n @arg config Configuration object\n @return Newly created null-terminated JSON string.  The ps_config_t\n retains ownership of this pointer, which is only valid until the\n next call to ps_config_serialize_json().  You must copy it if you\n wish to retain it."]
    pub fn ps_config_serialize_json(config: *mut ps_config_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Access the type of a configuration parameter.\n\n @memberof ps_config_t\n @param config Configuration object.\n @param name Name of the parameter to retrieve.\n @return the type of the parameter (as a combination of the ARG_*\n         bits), or 0 if no such parameter exists."]
    pub fn ps_config_typeof(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
    ) -> ps_type_t;
}
extern "C" {
    #[doc = " Access the value of a configuration parameter.\n\n To actually do something with the value, you will need to know its\n type, which can be obtained with ps_config_typeof().  This function\n is thus mainly useful for dynamic language bindings, and you should\n use ps_config_int(), ps_config_float(), or ps_config_str() instead.\n\n @memberof ps_config_t\n @param config Configuration object.\n @param name Name of the parameter to retrieve.\n @return Pointer to the parameter's value, or NULL if the parameter\n does not exist.  Note that a string parameter can also have NULL as\n a value, in which case the `ptr` field in the return value is NULL.\n This pointer (and any pointers inside it) is owned by the ps_config_t."]
    pub fn ps_config_get(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const anytype_t;
}
extern "C" {
    #[doc = " Set or unset the value of a configuration parameter.\n\n This will coerce the value to the proper type, so you can, for\n example, pass it a string with ARG_STRING as the type when adding\n options from the command-line.  Note that the return pointer will\n *not* be the same as the one passed in the value.\n\n @memberof ps_config_t\n @param config Configuration object.\n @param name Name of the parameter to set.  Must exist.\n @param val Pointer to the value (strings will be copied) inside an\n anytype_t union.  On 64-bit little-endian platforms, you *can* cast\n a pointer to int, long, double, or char* here, but that doesn't\n necessarily mean that you *should*.  As a convenience, you can pass\n NULL here to reset a parameter to its default value.\n @param t Type of the value in `val`, will be coerced to the type of\n the actual parameter if necessary.\n @return Pointer to the parameter's value, or NULL on failure\n (unknown parameter, usually).  This pointer (and any pointers\n inside it) is owned by the ps_config_t."]
    pub fn ps_config_set(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
        val: *const anytype_t,
        t: ps_type_t,
    ) -> *const anytype_t;
}
extern "C" {
    #[doc = " Get an integer-valued parameter.\n\n If the parameter does not have an integer or boolean type, this\n will print an error and return 0.  So don't do that.\n\n @memberof ps_config_t"]
    pub fn ps_config_int(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Get a boolean-valued parameter.\n\n If the parameter does not have an integer or boolean type, this\n will print an error and return 0.  The return value is either 0 or\n 1 (if the parameter has an integer type, any non-zero value will\n return 1).\n\n @memberof ps_config_t"]
    pub fn ps_config_bool(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a floating-point parameter.\n\n If the parameter does not have a floating-point type, this will\n print an error and return 0.\n\n @memberof ps_config_t"]
    pub fn ps_config_float(config: *mut ps_config_t, name: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[doc = " Get a string parameter.\n\n If the parameter does not have a string type, this will print an\n error and return NULL.  Notably, it will *NOT* format an integer or\n float for you, because that would involve allocating memory.  So\n don't do that.\n\n @memberof ps_config_t"]
    pub fn ps_config_str(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set an integer-valued parameter.\n\n If the parameter does not have an integer or boolean type, this\n will convert `val` appropriately.\n\n @memberof ps_config_t"]
    pub fn ps_config_set_int(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_long,
    ) -> *const anytype_t;
}
extern "C" {
    #[doc = " Set a boolean-valued parameter.\n\n If the parameter does not have an integer or boolean type, this\n will convert `val` appropriately.\n\n @memberof ps_config_t"]
    pub fn ps_config_set_bool(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
        val: ::std::os::raw::c_int,
    ) -> *const anytype_t;
}
extern "C" {
    #[doc = " Set a floating-point parameter.\n\n If the parameter does not have a floating-point type, this will\n convert `val` appropriately.\n\n @memberof ps_config_t"]
    pub fn ps_config_set_float(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
        val: f64,
    ) -> *const anytype_t;
}
extern "C" {
    #[doc = " Set a string-valued parameter.\n\n If the parameter does not have a string type, this will convert\n `val` appropriately.  For boolean parameters, any string matching\n `/^[yt1]/` will be true, while any string matching `/^[nf0]/` will\n be false.  NULL is also false.\n\n This function is used for configuration from JSON, you may want to\n use it for your own configuration files too.\n\n @memberof ps_config_t"]
    pub fn ps_config_set_str(
        config: *mut ps_config_t,
        name: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> *const anytype_t;
}
extern "C" {
    #[doc = " Set configuration parameters (actually just sample rate) from a\n sound file.\n\n If the file is unreadable, unsupported or incompatible with the\n existing feature extraction parameters, this will print an error\n message and fail (return -1).\n\n If it is of an unknown type, it will be treated as raw data.  So\n beware!  Currently we only support WAV and NIST Sphere files.  We\n attempt to recognize Ogg, MP3 (but not really, because it is very\n difficult to do reliably), and FLAC, but do not support them.  For\n everything else, there's SoX (tm).\n\n Currently, the file must be seekable, so you can't use this on\n standard input, for instance.\n\n @memberof ps_config_t\n @param config Configuration to update from file.\n @param fh Previously opened file handle.\n @param file Name of open file handle for logging (optional, can be NULL)"]
    pub fn ps_config_soundfile(
        config: *mut ps_config_t,
        fh: *mut FILE,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a WAV header and set configuration parameters.\n\n This works like ps_config_soundfile() but assumes that you already\n know it's a WAV file.\n\n Unlike ps_config_soundfile(), the file does *not* have to be seekable.\n\n @memberof ps_config_t\n @param config Configuration to update from file.\n @param infh Previously opened file handle.\n @param file Name of open file handle for logging (optional, can be NULL)"]
    pub fn ps_config_wavfile(
        config: *mut ps_config_t,
        infh: *mut FILE,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a NIST header and set configuration parameters.\n\n This works like ps_config_soundfile() but assumes that you already\n know it's a NIST file.\n\n Unlike ps_config_soundfile(), the file does *not* have to be seekable.\n\n @memberof ps_config_t\n @param config Configuration to update from file.\n @param infh Previously opened file handle.\n @param file Name of open file handle for logging (optional, can be NULL)"]
    pub fn ps_config_nistfile(
        config: *mut ps_config_t,
        infh: *mut FILE,
        file: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets default acoustic and language model if they are not set explicitly.\n\n This function fills in the configuration with the default acoustic\n and language models and dictionary, if (and this is a badly\n implemented heuristic) they do not seem to be already filled in.\n It is preferable for you to call this *before* doing any other\n configuration to avoid confusion.\n\n The default models are looked for in the directory returned by\n ps_default_modeldir(), or, if the `POCKETSPHINX_PATH` environment\n variable is set, this function will look there instead.\n\n If no global model directory was defined at compilation time (this\n is useful for relocatable installs such as the Python module) and\n `POCKETSPHINX_PATH` is not set, this will simply do nothing.\n\n @memberof ps_config_t"]
    pub fn ps_default_search_args(config: *mut ps_config_t);
}
extern "C" {
    #[doc = " Sets default file paths and parameters based on configuration.\n\n @memberof ps_config_t"]
    pub fn ps_expand_model_config(config: *mut ps_config_t);
}
extern "C" {
    #[doc = " Gets the system default model directory, if any exists.\n\n @relates ps_config_t\n @return system model directory defined at compile time, or NULL if\n         not defined (usually in a relocatable installation such as\n         a Python module)."]
    pub fn ps_default_modeldir() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize the decoder from a configuration object.\n\n @memberof ps_config_t\n @note The decoder retains ownership of the pointer\n <code>config</code>, so if you are not going to use it\n elsewhere, you can free it.\n @param config a configuration object.  If NULL, the\n decoder will be allocated but not initialized.  You can\n proceed to initialize it with ps_reinit()."]
    pub fn ps_init(config: *mut ps_config_t) -> *mut ps_decoder_t;
}
extern "C" {
    #[doc = " Reinitialize the decoder with updated configuration.\n\n This function allows you to switch the acoustic model, dictionary,\n or other configuration without creating an entirely new decoding\n object.\n\n @note Since the acoustic model will be reloaded, changes made to\n feature extraction parameters may be overridden if a `feat.params`\n file is present.\n @note Any searches created with ps_set_search() or words added to\n the dictionary with ps_add_word() will also be lost.  To avoid this\n you can use ps_reinit_feat().\n @note The decoder retains ownership of the pointer\n <code>config</code>, so you should free it when no longer used.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @param config An optional new configuration to use.  If this is\n               NULL, the previous configuration will be reloaded,\n               with any changes applied.\n @return 0 for success, <0 for failure."]
    pub fn ps_reinit(ps: *mut ps_decoder_t, config: *mut ps_config_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reinitialize only the feature computation with updated configuration.\n\n This function allows you to switch the feature computation\n parameters without otherwise affecting the decoder configuration.\n For example, if you change the sample rate or the frame rate, and\n do not want to reconfigure the rest of the decoder.\n\n Note that if you have set a custom cepstral mean with ps_set_cmn(),\n it will be overridden.\n\n @note The decoder retains ownership of the pointer `config`, so you\n should free it when no longer used.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @param config An optional new configuration to use.  If this is\n               NULL, the previous configuration will be reloaded,\n               with any changes to feature computation applied.\n @return 0 for success, <0 for failure (usually an invalid parameter)"]
    pub fn ps_reinit_feat(ps: *mut ps_decoder_t, config: *mut ps_config_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current cepstral mean as a string.\n\n This is the string representation of the current cepstral mean,\n which represents the acoustic channel conditions in live\n recognition.  This can be used to initialize the decoder with the\n `cmninit` option, e.g.:\n\n     config = ps_config_parse_json(NULL, \"cmninit: 42,-1,0\");\n\n @memberof ps_decoder_t\n @param ps Decoder\n @param update Update the cepstral mean using data processed so far.\n @return String representation of cepstral mean, as\n         `ps_config_get_int(config, \"ceplen\")` comma-separated\n         numbers.  This pointer is owned by the decoder and only\n         valid until the next call to ps_get_cmn(), ps_set_cmn() or\n         ps_end_utt()."]
    pub fn ps_get_cmn(
        ps: *mut ps_decoder_t,
        update: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the current cepstral mean from a string.\n\n This does the same thing as setting `cmninit` with\n ps_config_set_string() and running `ps_reinit_feat()` but is more\n efficient, and can also be done in the middle of an utterance if\n you like.\n\n @memberof ps_decoder_t\n @param ps Decoder\n @param cmn String representation of cepstral mean, as up to\n            `ps_config_get_int(config, \"ceplen\")` -separated numbers\n            (any missing values will be zero-filled).  @return 0 for\n            success of -1 for invalid input."]
    pub fn ps_set_cmn(
        ps: *mut ps_decoder_t,
        cmn: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the argument definitions used in ps_config_init().\n\n This is here to avoid exporting global data, which is problematic\n on Win32 and Symbian (and possibly other platforms).\n\n @related ps_config_t"]
    pub fn ps_args() -> *const ps_arg_t;
}
extern "C" {
    #[doc = " Retain a pointer to the decoder.\n\n This increments the reference count on the decoder, allowing it to\n be shared between multiple parent objects.  In general you will not\n need to use this function, ever.  It is mainly here for the\n convenience of scripting language bindings.\n\n @memberof ps_decoder_t\n @return pointer to retained decoder."]
    pub fn ps_retain(ps: *mut ps_decoder_t) -> *mut ps_decoder_t;
}
extern "C" {
    #[doc = " Finalize the decoder.\n\n This releases all resources associated with the decoder.\n\n @memberof ps_decoder_t\n @param ps Decoder to be freed.\n @return New reference count (0 if freed)."]
    pub fn ps_free(ps: *mut ps_decoder_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the configuration object for this decoder.\n\n @memberof ps_decoder_t\n @return The configuration object for this decoder.  The decoder\n         owns this pointer, so you should not attempt to free it\n         manually.  Use ps_config_retain() if you wish to reuse it\n         elsewhere."]
    pub fn ps_get_config(ps: *mut ps_decoder_t) -> *mut ps_config_t;
}
extern "C" {
    #[doc = " Get the log-math computation object for this decoder.\n\n @memberof ps_decoder_t\n @return The log-math object for this decoder.  The decoder owns\n         this pointer, so you should not attempt to free it\n         manually.  Use logmath_retain() if you wish to reuse it\n         elsewhere."]
    pub fn ps_get_logmath(ps: *mut ps_decoder_t) -> *mut logmath_t;
}
extern "C" {
    #[doc = " Adapt current acoustic model using a linear transform.\n\n @memberof ps_decoder_t\n @param mllr The new transform to use, or NULL to update the\n              existing transform.  The decoder retains ownership of\n              this pointer, so you may free it if you no longer need\n              it.\n @return The updated transform object for this decoder, or\n         NULL on failure."]
    pub fn ps_update_mllr(ps: *mut ps_decoder_t, mllr: *mut ps_mllr_t) -> *mut ps_mllr_t;
}
extern "C" {
    #[doc = " Reload the pronunciation dictionary from a file.\n\n This function replaces the current pronunciation dictionary with\n the one stored in `dictfile`.  This also causes the active search\n module(s) to be reinitialized, in the same manner as calling\n ps_add_word() with update=TRUE.\n\n @memberof ps_decoder_t\n @param dictfile Path to dictionary file to load.\n @param fdictfile Path to filler dictionary to load, or NULL to keep\n                  the existing filler dictionary.\n @param format Format of the dictionary file, or NULL to determine\n               automatically (currently unused,should be NULL)"]
    pub fn ps_load_dict(
        ps: *mut ps_decoder_t,
        dictfile: *const ::std::os::raw::c_char,
        fdictfile: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump the current pronunciation dictionary to a file.\n\n This function dumps the current pronunciation dictionary to a text file.\n\n @memberof ps_decoder_t\n @param dictfile Path to file where dictionary will be written.\n @param format Format of the dictionary file, or NULL for the\n               default (text) format (currently unused, should be NULL)"]
    pub fn ps_save_dict(
        ps: *mut ps_decoder_t,
        dictfile: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a word to the pronunciation dictionary.\n\n This function adds a word to the pronunciation dictionary and the\n current language model (but, obviously, not to the current FSG if\n FSG mode is enabled).  If the word is already present in one or the\n other, it does whatever is necessary to ensure that the word can be\n recognized.\n\n @memberof ps_decoder_t\n @param word Word string to add.\n @param phones Whitespace-separated list of phoneme strings\n               describing pronunciation of <code>word</code>.\n @param update If TRUE, update the search module (whichever one is\n               currently active) to recognize the newly added word.\n               If adding multiple words, it is more efficient to\n               pass FALSE here in all but the last word.\n @return The internal ID (>= 0) of the newly added word, or <0 on\n         failure."]
    pub fn ps_add_word(
        ps: *mut ps_decoder_t,
        word: *const ::std::os::raw::c_char,
        phones: *const ::std::os::raw::c_char,
        update: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look up a word in the dictionary and return phone transcription\n for it.\n\n @memberof ps_decoder_t\n @param ps Pocketsphinx decoder\n @param word Word to look for\n\n @return Whitespace-spearated phone string describing the pronunciation of the <code>word</code>\n         or NULL if word is not present in the dictionary. The string is\n         allocated and must be freed by the user."]
    pub fn ps_lookup_word(
        ps: *mut ps_decoder_t,
        word: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Decode a raw audio stream.\n\n No headers are recognized in this files.  The configuration\n parameters <tt>-samprate</tt> and <tt>-input_endian</tt> are used\n to determine the sampling rate and endianness of the stream,\n respectively.  Audio is always assumed to be 16-bit signed PCM.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @param rawfh Previously opened file stream.\n @param maxsamps Maximum number of samples to read from rawfh, or -1\n                 to read until end-of-file.\n @return Number of samples of audio."]
    pub fn ps_decode_raw(
        ps: *mut ps_decoder_t,
        rawfh: *mut FILE,
        maxsamps: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[doc = " Decode a senone score dump file.\n\n @memberof ps_decoder_t\n @param ps Decoder\n @param senfh Previously opened file handle positioned at start of file.\n @return Number of frames read."]
    pub fn ps_decode_senscr(ps: *mut ps_decoder_t, senfh: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start processing of the stream of speech.\n\n @deprecated This function is retained for compatibility, but its\n only effect is to reset the noise removal statistics, which are\n otherwise retained across utterances.  You do not need to call it.\n\n @memberof ps_decoder_t\n @return 0 for success, <0 on error."]
    pub fn ps_start_stream(ps: *mut ps_decoder_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check in-speech status of decoder.\n\n @deprecated This function is retained for compatibility but should\n not be considered a reliable voice activity detector.  It will\n always return 1 between calls to ps_start_utt() and ps_end_utt().\n You probably want ps_endpointer_t, but for single frames of data\n you can also use \\ref ps_vad_t.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @return 1 if last buffer contained speech, 0 - otherwise"]
    pub fn ps_get_in_speech(ps: *mut ps_decoder_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start utterance processing.\n\n This function should be called before any utterance data is passed\n to the decoder.  It marks the start of a new utterance and\n reinitializes internal data structures.\n\n @memberof ps_decoder_t\n @param ps Decoder to be started.\n @return 0 for success, <0 on error."]
    pub fn ps_start_utt(ps: *mut ps_decoder_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode raw audio data.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @param data Audio data, as 16-bit linear PCM.\n @param n_samples Number of samples (not bytes) in `data`.\n @param no_search If non-zero, perform feature extraction but don't\n                  do any recognition yet.  This may be necessary if\n                  your processor has trouble doing recognition in\n                  real-time.\n @param full_utt If non-zero, this block of data is a full utterance\n                 worth of data.  This may allow the recognizer to\n                 produce more accurate results.\n @return Number of frames of data searched, or <0 for error."]
    pub fn ps_process_raw(
        ps: *mut ps_decoder_t,
        data: *const int16,
        n_samples: usize,
        no_search: ::std::os::raw::c_int,
        full_utt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode acoustic feature data.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @param data Acoustic feature data, a 2-dimensional array of 32-bit\n             floating-point values.  Note that this is not a standard\n             2-dimesional C array but rather an array of pointers to\n             floats, each of which is one vector (or frame) of\n             `ps_config_get_int(\"ceplen\")` values.\n @param n_frames Number of vectors in `data`.\n @param no_search If non-zero, perform feature extraction but don't\n                  do any recognition yet.  This may be necessary if\n                  your processor has trouble doing recognition in\n                  real-time.\n @param full_utt If non-zero, this block of data is a full utterance\n                 worth of data.  This may allow the recognizer to\n                 produce more accurate results.\n @return Number of frames of data searched, or <0 for error."]
    pub fn ps_process_cep(
        ps: *mut ps_decoder_t,
        data: *mut *mut float32,
        n_frames: ::std::os::raw::c_int,
        no_search: ::std::os::raw::c_int,
        full_utt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of frames of data searched.\n\n Note that there is a delay between this and the number of frames of\n audio which have been input to the system.  This is due to the fact\n that acoustic features are computed using a sliding window of\n audio, and dynamic features are computed over a sliding window of\n acoustic features.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @return Number of frames of speech data which have been recognized\n so far."]
    pub fn ps_get_n_frames(ps: *mut ps_decoder_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " End utterance processing.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @return 0 for success, <0 on error"]
    pub fn ps_end_utt(ps: *mut ps_decoder_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get hypothesis string and path score.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @param out_best_score Output: path score corresponding to returned string.\n @return String containing best hypothesis at this point in\n         decoding.  NULL if no hypothesis is available.  This string is owned\n         by the decoder and only valid for the current hypothesis, so you\n         should copy it if you need to hold onto it."]
    pub fn ps_get_hyp(
        ps: *mut ps_decoder_t,
        out_best_score: *mut int32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get posterior probability.\n\n @note Unless the -bestpath option is enabled, this function will\n always return zero (corresponding to a posterior probability of\n 1.0).  Even if -bestpath is enabled, it will also return zero when\n called on a partial result.  Ongoing research into effective\n confidence annotation for partial hypotheses may result in these\n restrictions being lifted in future versions.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @return Posterior probability of the best hypothesis."]
    pub fn ps_get_prob(ps: *mut ps_decoder_t) -> int32;
}
extern "C" {
    #[doc = " Get word lattice.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @return Word lattice object containing all hypotheses so far.  NULL\n         if no hypotheses are available.  This pointer is owned by\n         the decoder and you should not attempt to free it manually.\n         It is only valid until the next utterance, unless you use\n         ps_lattice_retain() to retain it."]
    pub fn ps_get_lattice(ps: *mut ps_decoder_t) -> *mut ps_lattice_t;
}
extern "C" {
    #[doc = " Get an iterator over the word segmentation for the best hypothesis.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @return Iterator over the best hypothesis at this point in\n         decoding.  NULL if no hypothesis is available."]
    pub fn ps_seg_iter(ps: *mut ps_decoder_t) -> *mut ps_seg_t;
}
extern "C" {
    #[doc = " Get the next segment in a word segmentation.\n\n @memberof ps_seg_t\n @param seg Segment iterator.\n @return Updated iterator with the next segment.  NULL at end of\n         utterance (the iterator will be freed in this case)."]
    pub fn ps_seg_next(seg: *mut ps_seg_t) -> *mut ps_seg_t;
}
extern "C" {
    #[doc = " Get word string from a segmentation iterator.\n\n @memberof ps_seg_t\n @param seg Segment iterator.\n @return Read-only string giving string name of this segment.  This\n is only valid until the next call to ps_seg_next()."]
    pub fn ps_seg_word(seg: *mut ps_seg_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get inclusive start and end frames from a segmentation iterator.\n\n @note These frame numbers are inclusive, i.e. the end frame refers\n to the last frame in which the given word or other segment was\n active.  Therefore, the actual duration is *out_ef - *out_sf + 1.\n\n @memberof ps_seg_t\n @param seg Segment iterator.\n @param out_sf Output: First frame index in segment.\n @param out_ef Output: Last frame index in segment."]
    pub fn ps_seg_frames(
        seg: *mut ps_seg_t,
        out_sf: *mut ::std::os::raw::c_int,
        out_ef: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get language, acoustic, and posterior probabilities from a\n segmentation iterator.\n\n @note Unless the -bestpath option is enabled, this function will\n always return zero (corresponding to a posterior probability of\n 1.0).  Even if -bestpath is enabled, it will also return zero when\n called on a partial result.  Ongoing research into effective\n confidence annotation for partial hypotheses may result in these\n restrictions being lifted in future versions.\n\n @memberof ps_seg_t\n @param out_ascr Output: acoustic model score for this segment.\n @param out_lscr Output: language model score for this segment.\n @param out_lback Output: language model backoff mode for this\n                  segment (i.e. the number of words used in\n                  calculating lscr).  This field is, of course, only\n                  meaningful for N-Gram models.\n @return Log posterior probability of current segment.  Log is\n         expressed in the log-base used in the decoder.  To convert\n         to linear floating-point, use logmath_exp(ps_get_logmath(),\n         pprob)."]
    pub fn ps_seg_prob(
        seg: *mut ps_seg_t,
        out_ascr: *mut int32,
        out_lscr: *mut int32,
        out_lback: *mut int32,
    ) -> int32;
}
extern "C" {
    #[doc = " Finish iterating over a word segmentation early, freeing resources.\n @memberof ps_seg_t"]
    pub fn ps_seg_free(seg: *mut ps_seg_t);
}
extern "C" {
    #[doc = " Get an iterator over the best hypotheses. The function may also\n return a NULL which means that there is no hypothesis available for this\n utterance.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @return Iterator over N-best hypotheses or NULL if no hypothesis is available"]
    pub fn ps_nbest(ps: *mut ps_decoder_t) -> *mut ps_nbest_t;
}
extern "C" {
    #[doc = " Move an N-best list iterator forward.\n\n @memberof ps_nbest_t\n @param nbest N-best iterator.\n @return Updated N-best iterator, or NULL if no more hypotheses are\n         available (iterator is freed ni this case)."]
    pub fn ps_nbest_next(nbest: *mut ps_nbest_t) -> *mut ps_nbest_t;
}
extern "C" {
    #[doc = " Get the hypothesis string from an N-best list iterator.\n\n @memberof ps_nbest_t\n @param nbest N-best iterator.\n @param out_score Output: Path score for this hypothesis.\n @return String containing next best hypothesis. Note that this\n         pointer is only valid for the current iteration."]
    pub fn ps_nbest_hyp(
        nbest: *mut ps_nbest_t,
        out_score: *mut int32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the word segmentation from an N-best list iterator.\n\n @memberof ps_nbest_t\n @param nbest N-best iterator.\n @return Iterator over the next best hypothesis."]
    pub fn ps_nbest_seg(nbest: *mut ps_nbest_t) -> *mut ps_seg_t;
}
extern "C" {
    #[doc = " Finish N-best search early, releasing resources.\n\n @memberof ps_nbest_t\n @param nbest N-best iterator."]
    pub fn ps_nbest_free(nbest: *mut ps_nbest_t);
}
extern "C" {
    #[doc = " Get performance information for the current utterance.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @param out_nspeech Output: Number of seconds of speech.\n @param out_ncpu    Output: Number of seconds of CPU time used.\n @param out_nwall   Output: Number of seconds of wall time used."]
    pub fn ps_get_utt_time(
        ps: *mut ps_decoder_t,
        out_nspeech: *mut f64,
        out_ncpu: *mut f64,
        out_nwall: *mut f64,
    );
}
extern "C" {
    #[doc = " Get overall performance information.\n\n @memberof ps_decoder_t\n @param ps Decoder.\n @param out_nspeech Output: Number of seconds of speech.\n @param out_ncpu    Output: Number of seconds of CPU time used.\n @param out_nwall   Output: Number of seconds of wall time used."]
    pub fn ps_get_all_time(
        ps: *mut ps_decoder_t,
        out_nspeech: *mut f64,
        out_ncpu: *mut f64,
        out_nwall: *mut f64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
